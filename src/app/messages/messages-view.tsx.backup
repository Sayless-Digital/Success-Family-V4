"use client"

import { useCallback, useEffect, useMemo, useRef, useState, startTransition } from "react"
import Image from "next/image"
import { usePathname, useRouter, useSearchParams } from "next/navigation"
import type { RealtimeChannel } from "@supabase/supabase-js"
import {
  ArrowLeft,
  Check,
  CheckCheck,
  ChevronDown,
  ChevronUp,
  Download,
  FileText,
  Image as ImageIcon,
  Loader2,
  MessageCircle,
  Mic,
  Paperclip,
  Play,
  Reply,
  Search,
  Send,
  Trash2,
  Video,
  X,
} from "lucide-react"
import { toast } from "sonner"

import { supabase } from "@/lib/supabase"
import {
  DM_TYPING_EVENT,
  buildDmMediaStoragePath,
  getThreadChannelName,
  type ConversationListItem,
  type MessageResult,
} from "@/lib/chat-shared"
import type { DirectMessageParticipant, DirectMessageThread } from "@/types"
import { cn, formatRelativeTime, linkifyText } from "@/lib/utils"
import { VoiceNoteRecorder } from "@/components/voice-note-recorder"
import { VoiceNotePlayer } from "@/components/voice-note-player"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { useUnreadMessagesPerThread } from "@/hooks/use-unread-messages-per-thread"
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu"
import { MessageImageLightbox } from "@/components/message-image-lightbox"
import { Input } from "@/components/ui/input"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Separator } from "@/components/ui/separator"
import { EmojiPicker } from "@/components/emoji-picker"

type ViewerProfile = {
  id: string
  username: string | null
  first_name: string | null
  last_name: string | null
  profile_picture: string | null
}

type AttachmentState = {
  id: string
  fileName: string
  mediaType: "image" | "audio" | "file" | "video"
  status: "uploading" | "ready" | "error"
  previewUrl?: string
  storagePath?: string
  objectPath?: string
  mimeType?: string
  fileSize?: number
  durationSeconds?: number
  error?: string
}

type ThreadPaginationState = Record<string, { hasMore: boolean; nextCursor: string | null }>

interface MessagesViewProps {
  viewer: ViewerProfile
  initialConversations: ConversationListItem[]
  initialThreadId: string | null
  initialMessagesByThread: Record<string, MessageResult[]>
  initialPaginationByThread: ThreadPaginationState
}

const DEFAULT_PAGE_SIZE = 50
const SIGNED_URL_TTL_SECONDS = 60 * 15 // 15 minutes
const SIGNED_URL_REFRESH_THRESHOLD = 60 * 10 // Refresh after 10 minutes
const MAX_ATTACHMENTS = 6
const TYPING_EXPIRATION_MS = 4000
const TYPING_DEBOUNCE_MS = 1200

function getDisplayName(profile: ViewerProfile | ConversationListItem["other_user_profile"]) {
  if (!profile) return "Unknown User"
  const fullName = `${profile.first_name ?? ""} ${profile.last_name ?? ""}`.trim()
  if (fullName.length > 0) return fullName
  if (profile.username) return `@${profile.username}`
  return "Unknown User"
}

function getInitials(
  profile: ViewerProfile | ConversationListItem["other_user_profile"],
) {
  if (!profile) return "?"
  const first = profile.first_name?.[0]
  const last = profile.last_name?.[0]
  if (first || last) {
    return `${first ?? ""}${last ?? ""}`.toUpperCase()
  }
  return profile.username?.slice(0, 2)?.toUpperCase() ?? "?"
}

function storagePathToObjectPath(storagePath: string | null | undefined) {
  if (!storagePath) return null
  const prefix = "dm-media/"
  if (storagePath.startsWith(prefix)) {
    return storagePath.slice(prefix.length)
  }
  return storagePath
}

function formatTimestamp(iso?: string | null) {
  if (!iso) return ""
  const date = new Date(iso)
  return date.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" })
}

export default function MessagesView({
  viewer,
  initialConversations,
  initialThreadId,
  initialMessagesByThread,
  initialPaginationByThread,
}: MessagesViewProps) {
  const [conversations, setConversations] = useState<ConversationListItem[]>(initialConversations)
  const [displayedConversations, setDisplayedConversations] = useState<ConversationListItem[]>(initialConversations)
  const [searchTerm, setSearchTerm] = useState("")
  const [searchLoading, setSearchLoading] = useState(false)
  const [selectedThreadId, setSelectedThreadId] = useState<string | null>(initialThreadId)
  const [messagesByThread, setMessagesByThread] = useState<Record<string, MessageResult[]>>(initialMessagesByThread)
  const [threadPagination, setThreadPagination] = useState<ThreadPaginationState>(initialPaginationByThread)
  const [loadingThreadId, setLoadingThreadId] = useState<string | null>(null)
  const [composerValue, setComposerValue] = useState("")
  const [isSending, setIsSending] = useState(false)
  const [attachments, setAttachments] = useState<AttachmentState[]>([])
  const [replyingToMessage, setReplyingToMessage] = useState<MessageResult | null>(null)
  const [highlightedMessageId, setHighlightedMessageId] = useState<string | null>(null)
  const [showScrollToBottom, setShowScrollToBottom] = useState(false)
  
  // Debug: Log attachments state changes
  useEffect(() => {
    console.log('[Attachments State] State changed:', {
      count: attachments.length,
      attachments: attachments.map(a => ({
        id: a.id,
        fileName: a.fileName,
        mediaType: a.mediaType,
        status: a.status,
        hasPreviewUrl: !!a.previewUrl
      }))
    })
  }, [attachments])
  
  const [isVoiceRecorderOpen, setIsVoiceRecorderOpen] = useState(false)
  const [typingIndicators, setTypingIndicators] = useState<Record<string, { userId: string; expiresAt: number }>>({})
  const [displayTypingIndicators, setDisplayTypingIndicators] = useState<Record<string, boolean>>({})
  const [presenceMap, setPresenceMap] = useState<Record<string, boolean>>({})
  const [attachmentUrls, setAttachmentUrls] = useState<Record<string, { url: string; expiresAt: number }>>({})
  const [conversationImagePreviews, setConversationImagePreviews] = useState<Record<string, { url: string; expiresAt: number }>>({})
  const [isMobile, setIsMobile] = useState(false)
  const [mobileView, setMobileView] = useState<"list" | "conversation">("list")
  const [isClient, setIsClient] = useState(false)
  const [loadingOlderMessages, setLoadingOlderMessages] = useState(false)
  const [deletingMessageId, setDeletingMessageId] = useState<string | null>(null)
  const [playingAudio, setPlayingAudio] = useState<string | null>(null)
  const [playingVideo, setPlayingVideo] = useState<string | null>(null)
  const [longPressMenuOpen, setLongPressMenuOpen] = useState<string | null>(null)
  const [attachMenuOpen, setAttachMenuOpen] = useState(false)
  const [downloadingAttachmentId, setDownloadingAttachmentId] = useState<string | null>(null)
  const [lightboxOpen, setLightboxOpen] = useState(false)
  const [lightboxImages, setLightboxImages] = useState<Array<{ id: string; url: string }>>([])
  const [lightboxIndex, setLightboxIndex] = useState(0)
  const [swipeOffset, setSwipeOffset] = useState<Record<string, number>>({})
  const [swipingMessageId, setSwipingMessageId] = useState<string | null>(null)
  const videoRefs = useRef<Record<string, HTMLVideoElement>>({})
  const fileInputRefs = useRef<Record<string, HTMLInputElement | null>>({})
  const longPressTimer = useRef<NodeJS.Timeout | null>(null)
  const touchStart = useRef<{ x: number; y: number } | null>(null)
  const swipeTouchStart = useRef<{ x: number; y: number; messageId: string } | null>(null)
  const abortControllerRef = useRef<AbortController | null>(null)
  const textareaRef = useRef<HTMLTextAreaElement | null>(null)

  // Get unread message counts per thread
  const threadIds = conversations.map((c) => c.thread_id)
  const { unreadCounts } = useUnreadMessagesPerThread(viewer.id, threadIds)

  const searchParams = useSearchParams()
  const router = useRouter()
  const pathname = usePathname()

  const messageContainerRef = useRef<HTMLDivElement | null>(null)
  const messageRefs = useRef<Map<string, HTMLDivElement>>(new Map())
  const highlightedMessageIdRef = useRef<string | null>(null)
  const channelRef = useRef<RealtimeChannel | null>(null)
  const messagesChannelRef = useRef<RealtimeChannel | null>(null)
  const threadsChannelRef = useRef<RealtimeChannel | null>(null)
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const typingBroadcastCooldownRef = useRef<NodeJS.Timeout | null>(null)
  const typingDisplayTimeoutRef = useRef<Record<string, NodeJS.Timeout>>({})
  const searchDebounceRef = useRef<NodeJS.Timeout | null>(null)
  const attachmentsRef = useRef<AttachmentState[]>(attachments)
  const messagesRef = useRef(messagesByThread)
  const conversationsRef = useRef(conversations)
  const lastThreadFromQueryRef = useRef<string | null>(null)
  const selectedThreadIdRef = useRef<string | null>(null)
  const mobileViewRef = useRef<"list" | "conversation">(mobileView)
  const isMobileRef = useRef(isMobile)

  useEffect(() => {
    attachmentsRef.current = attachments
  }, [attachments])

  useEffect(() => {
    return () => {
      attachmentsRef.current.forEach((attachment) => {
        if (attachment.previewUrl) {
          URL.revokeObjectURL(attachment.previewUrl)
        }
      })
      // Voice note audio elements are cleaned up by VoiceNotePlayer component
    }
  }, [])

  useEffect(() => {
    messagesRef.current = messagesByThread
  }, [messagesByThread])

  useEffect(() => {
    conversationsRef.current = conversations
  }, [conversations])

  useEffect(() => {
    selectedThreadIdRef.current = selectedThreadId
  }, [selectedThreadId])

  useEffect(() => {
    mobileViewRef.current = mobileView
  }, [mobileView])

  useEffect(() => {
    isMobileRef.current = isMobile
  }, [isMobile])

  const selectedConversation = useMemo(
    () => conversations.find((item) => item.thread_id === selectedThreadId) ?? null,
    [conversations, selectedThreadId],
  )

  const selectedMessages = selectedThreadId ? messagesByThread[selectedThreadId] ?? [] : []

  // Compute live previews from actual messages in threads
  const liveMessagePreviews = useMemo(() => {
    const previews: Record<string, { content: string; senderId: string | null; timestamp: string | null; hasImage: boolean }> = {}
    
    Object.entries(messagesByThread).forEach(([threadId, messages]) => {
      if (messages && messages.length > 0) {
        const lastMessage = messages[messages.length - 1]
        const imageAttachments = lastMessage.attachments?.filter(a => a.media_type === "image") ?? []
        const hasImage = imageAttachments.length > 0
        previews[threadId] = {
          content: lastMessage.content ?? (hasImage ? "[image]" : (lastMessage.attachments?.length ? "[attachment]" : "")),
          senderId: lastMessage.sender_id,
          timestamp: lastMessage.created_at,
          hasImage,
        }
      }
    })
    
    return previews
  }, [messagesByThread])

  // Fetch image previews for conversations with image attachments
  useEffect(() => {
    const fetchImagePreviews = async () => {
      const now = Date.now()
      const threadsToFetch: string[] = []

      // Check which conversations need image previews
      conversations.forEach((conversation) => {
        const threadId = conversation.thread_id
        const existing = conversationImagePreviews[threadId]
        
        // Skip if we already have a valid URL
        if (existing && existing.expiresAt > now + SIGNED_URL_REFRESH_THRESHOLD * 1000) {
          return
        }

        // Check if this conversation has an image in the last message
        const livePreview = liveMessagePreviews[threadId]
        const hasImage = livePreview?.hasImage || false
        
        // Also check if the preview text indicates an image
        const previewText = livePreview?.content || conversation.last_message_preview || ""
        const isImageMessage = previewText === "[image]" || previewText === "[attachment]"
        
        if (hasImage || isImageMessage) {
          threadsToFetch.push(threadId)
        }
      })

      if (threadsToFetch.length === 0) return

      // Fetch the last message with image attachments for each thread
      await Promise.all(
        threadsToFetch.map(async (threadId) => {
          try {
            const { data: lastMessage } = await supabase
              .from("dm_messages")
              .select("id")
              .eq("thread_id", threadId)
              .order("created_at", { ascending: false })
              .limit(1)
              .maybeSingle()

            if (!lastMessage) return

            const { data: imageAttachments } = await supabase
              .from("dm_message_media")
              .select("id, storage_path, media_type")
              .eq("message_id", lastMessage.id)
              .eq("media_type", "image")
              .limit(1)

            if (!imageAttachments || imageAttachments.length === 0) return

            const imageAttachment = imageAttachments[0]
            const objectPath = storagePathToObjectPath(imageAttachment.storage_path)
            if (!objectPath) return

            const { data: signedUrlData } = await supabase.storage
              .from("dm-media")
              .createSignedUrl(objectPath, SIGNED_URL_TTL_SECONDS)

            if (signedUrlData?.signedUrl) {
              setConversationImagePreviews((prev) => ({
                ...prev,
                [threadId]: {
                  url: signedUrlData.signedUrl,
                  expiresAt: now + SIGNED_URL_TTL_SECONDS * 1000,
                },
              }))
            }
          } catch (error) {
            console.error(`[fetchImagePreviews] Error fetching preview for thread ${threadId}:`, error)
          }
        }),
      )
    }

    fetchImagePreviews()
  }, [conversations, liveMessagePreviews, conversationImagePreviews])

  useEffect(() => {
    setIsClient(true)
    const handleResize = () => {
      setIsMobile(window.innerWidth < 1024)
    }
    handleResize()
    window.addEventListener("resize", handleResize)
    return () => window.removeEventListener("resize", handleResize)
  }, [])

  useEffect(() => {
    if (!searchTerm.trim()) {
      setDisplayedConversations(conversations)
      return
    }
    // Debounced remote search
    if (searchDebounceRef.current) clearTimeout(searchDebounceRef.current)
    searchDebounceRef.current = setTimeout(async () => {
      try {
        setSearchLoading(true)
        const params = new URLSearchParams()
        params.set("search", searchTerm.trim())
        params.set("limit", "30")
        const response = await fetch(`/api/dm/threads?${params.toString()}`, { cache: "no-store" })
        if (!response.ok) {
          throw new Error("Failed to search conversations")
        }
        const data = await response.json()
        setDisplayedConversations(data.conversations ?? [])
      } catch (error) {
        console.error(error)
        toast.error("Unable to search conversations right now.")
      } finally {
        setSearchLoading(false)
      }
    }, 350)

    return () => {
      if (searchDebounceRef.current) {
        clearTimeout(searchDebounceRef.current)
        searchDebounceRef.current = null
      }
    }
  }, [searchTerm])

  useEffect(() => {
    if (searchTerm.trim()) return
    setDisplayedConversations(conversations)
  }, [conversations, searchTerm])

  // Scroll to bottom when thread changes
  useEffect(() => {
    if (!selectedThreadId) return
    const container = messageContainerRef.current
    if (!container) return
    // Use requestAnimationFrame to ensure DOM is updated
    requestAnimationFrame(() => {
      container.scrollTop = container.scrollHeight
    })
  }, [selectedThreadId])

  // Scroll to bottom when new messages arrive (only if user is near bottom)
  useEffect(() => {
    if (!selectedThreadId) return
    const container = messageContainerRef.current
    if (!container) return
    // Only auto-scroll if user is near the bottom (within 100px)
    const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100
    if (isNearBottom) {
      requestAnimationFrame(() => {
        container.scrollTop = container.scrollHeight
      })
    }
  }, [selectedMessages.length, selectedThreadId])

  const ensureAttachmentUrls = useCallback(
    async (attachmentsToEnsure: MessageResult["attachments"], forceRefresh = false) => {
      if (!attachmentsToEnsure || attachmentsToEnsure.length === 0) return

      const now = Date.now()

      await Promise.all(
        attachmentsToEnsure.map(async (attachment: any) => {
          const existing = attachmentUrls[attachment.id]
          
          // Skip if URL exists and hasn't expired (unless force refresh)
          if (!forceRefresh && existing && existing.expiresAt > now + SIGNED_URL_REFRESH_THRESHOLD * 1000) {
            return
          }

          // If attachment has source_storage_path, it needs to be copied first
          if (attachment.source_storage_path && attachment.source_bucket) {
            // Find the message ID to copy the file
            const messageId = attachment.message_id
            if (messageId) {
              try {
                await fetch("/api/dm/copy-boost-attachments", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ messageId }),
                })
                // Wait a bit for the copy to complete
                await new Promise(resolve => setTimeout(resolve, 500))
                // Re-fetch the attachment to get updated storage_path
                const { data: updatedAttachment } = await supabase
                  .from("dm_message_media")
                  .select("storage_path")
                  .eq("id", attachment.id)
                  .single()
                if (updatedAttachment) {
                  attachment.storage_path = updatedAttachment.storage_path
                }
              } catch (error) {
                console.error("Error copying boost reward attachment:", error)
                return
              }
            }
          }

          const objectPath = storagePathToObjectPath(attachment.storage_path)
          if (!objectPath) {
            // Silently skip if no valid object path
            return
          }

          try {
            const { data, error } = await supabase.storage
              .from("dm-media")
              .createSignedUrl(objectPath, SIGNED_URL_TTL_SECONDS)

            // Silently skip if any error occurs (file not found, permissions, etc.)
            if (error || !data?.signedUrl) {
              return
            }

            setAttachmentUrls((prev) => ({
              ...prev,
              [attachment.id]: {
                url: data.signedUrl,
                expiresAt: now + SIGNED_URL_TTL_SECONDS * 1000,
              },
            }))
          } catch (error) {
            // Silently catch and ignore all exceptions to prevent console spam
            return
          }
        }),
      )
    },
    [attachmentUrls],
  )

  useEffect(() => {
    if (!selectedMessages.length) return
    ensureAttachmentUrls(selectedMessages.flatMap((message) => message.attachments ?? []))
  }, [selectedMessages, ensureAttachmentUrls])

  // Ensure attachment URLs for replying to message
  useEffect(() => {
    if (!replyingToMessage?.attachments?.length) return
    ensureAttachmentUrls(replyingToMessage.attachments)
  }, [replyingToMessage?.attachments, ensureAttachmentUrls])

  // Ensure attachment URLs for replied messages in current thread
  useEffect(() => {
    if (!selectedThreadId) return
    const threadMessages = messagesByThread[selectedThreadId] ?? []
    const repliedMessageIds = new Set<string>()
    
    // Collect attachments from replied_to_message data
    const repliedAttachments: MessageResult["attachments"] = []
    threadMessages.forEach(message => {
      if (message.replied_to_message?.attachments) {
        repliedAttachments.push(...message.replied_to_message.attachments)
      }
    })
    
    if (repliedAttachments.length > 0) {
      ensureAttachmentUrls(repliedAttachments)
    }
  }, [selectedThreadId, messagesByThread, ensureAttachmentUrls])

  // Voice note audio elements are now managed by VoiceNotePlayer component

  useEffect(() => {
    if (selectedThreadId) return

    const fallback =
      selectedConversation?.thread_id ??
      conversationsRef.current[0]?.thread_id ??
      displayedConversations[0]?.thread_id ??
      initialThreadId ??
      null

    if (fallback) {
      setSelectedThreadId(fallback)
    }
  }, [selectedThreadId, selectedConversation, displayedConversations, initialThreadId])

  // Set mobile view to conversation when initialThreadId is provided (e.g., from query parameter)
  useEffect(() => {
    if (initialThreadId && isMobile && isClient) {
      setMobileView("conversation")
    }
  }, [initialThreadId, isMobile, isClient])

  const refreshConversations = useCallback(async () => {
    const response = await fetch("/api/dm/threads?limit=30", { cache: "no-store" })
    if (!response.ok) {
      throw new Error("Failed to refresh conversations")
    }

    const data = await response.json()
    const list: ConversationListItem[] = data.conversations ?? []
    setConversations(list)
    if (!searchTerm.trim()) {
      setDisplayedConversations(list)
    }
    return list
  }, [searchTerm])

  // Prefetch messages for conversations on hover (desktop only) for instant switching
  // Use a ref to track prefetch timeouts to debounce rapid hovers
  const prefetchTimeoutRef = useRef<Record<string, NodeJS.Timeout>>({})
  
  const prefetchMessages = useCallback(
    async (threadId: string) => {
      // Only prefetch if messages aren't already loaded
      if (messagesRef.current[threadId]) {
        return
      }

      // Clear any existing timeout for this thread
      if (prefetchTimeoutRef.current[threadId]) {
        clearTimeout(prefetchTimeoutRef.current[threadId])
      }

      // Debounce prefetch - wait 150ms after hover to avoid prefetching on quick mouse moves
      prefetchTimeoutRef.current[threadId] = setTimeout(() => {
        // Double-check messages aren't loaded (might have been loaded by click)
        if (messagesRef.current[threadId]) {
          delete prefetchTimeoutRef.current[threadId]
          return
        }

        // Prefetch in background - don't await
        fetch(`/api/dm/threads/${threadId}/messages?limit=${DEFAULT_PAGE_SIZE}`, {
          cache: "no-store",
        })
          .then(async (response) => {
            if (!response.ok) {
              delete prefetchTimeoutRef.current[threadId]
              return
            }
            const data = await response.json()
            const fetchedMessages: MessageResult[] = data.messages ?? []
            
            // Double-check we still need to cache (might have been loaded by click)
            if (messagesRef.current[threadId]) {
              delete prefetchTimeoutRef.current[threadId]
              return
            }
            
            // Cache messages silently
            setMessagesByThread((prev) => ({
              ...prev,
              [threadId]: fetchedMessages,
            }))
            setThreadPagination((prev) => ({
              ...prev,
              [threadId]: {
                hasMore: Boolean(data.pageInfo?.hasMore),
                nextCursor: data.pageInfo?.nextCursor ?? null,
              },
            }))
            
            // Prefetch attachment URLs in background (non-blocking)
            ensureAttachmentUrls(fetchedMessages.flatMap((m) => m.attachments ?? [])).catch(() => {
              // Silent fail - non-critical
            }).finally(() => {
              delete prefetchTimeoutRef.current[threadId]
            })
          })
          .catch(() => {
            // Silent fail - prefetch is optional
            delete prefetchTimeoutRef.current[threadId]
          })
      }, 150) // 150ms debounce
    },
    [ensureAttachmentUrls],
  )

  // Prefetch messages for top conversations on load (desktop only) for faster switching
  useEffect(() => {
    if (isMobile || !isClient) return
    
    // Prefetch top 3 conversations (most likely to be opened)
    const topConversations = conversations.slice(0, 3)
    topConversations.forEach((conversation, index) => {
      // Stagger prefetch slightly to avoid overwhelming the server
      setTimeout(() => {
        if (!messagesRef.current[conversation.thread_id]) {
          prefetchMessages(conversation.thread_id)
        }
      }, index * 200) // 200ms delay between each prefetch
    })
  }, [conversations, isMobile, isClient, prefetchMessages])

  const handleSelectConversation = useCallback(
    async (threadId: string) => {
      const normalizedThreadId = threadId.trim()
      
      // Cancel any pending prefetch for this thread
      if (prefetchTimeoutRef.current[normalizedThreadId]) {
        clearTimeout(prefetchTimeoutRef.current[normalizedThreadId])
        delete prefetchTimeoutRef.current[normalizedThreadId]
      }

      // Cancel any in-flight fetch requests for previous conversation
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }
      
      // Create new AbortController for this request
      const abortController = new AbortController()
      abortControllerRef.current = abortController
      
      // Immediately update UI state for instant feedback (SPA-like)
      // Use startTransition to make state updates non-blocking
      startTransition(() => {
        setSelectedThreadId(normalizedThreadId)
        if (isMobile) {
          setMobileView("conversation")
        }
      })

      // If messages are already cached, update URL and we're done - instant switch!
      if (messagesRef.current[normalizedThreadId]) {
        // Update URL asynchronously (non-blocking)
        startTransition(() => {
          const currentThreadParam = searchParams?.get("thread")
          const hasPeerParam = !!searchParams?.get("peerId")
          if (currentThreadParam !== normalizedThreadId || hasPeerParam) {
            const nextParams = new URLSearchParams(searchParams?.toString() ?? "")
            nextParams.set("thread", normalizedThreadId)
            nextParams.delete("peerId")
            const queryString = nextParams.toString()
            router.replace(queryString ? `${pathname}?${queryString}` : pathname, { scroll: false })
          }
        })
        setLoadingThreadId(null)
        return
      }

      // Set loading state immediately so UI can show loading indicator
      setLoadingThreadId(normalizedThreadId)

      // Update URL asynchronously (non-blocking) - use startTransition
      startTransition(() => {
        const currentThreadParam = searchParams?.get("thread")
        const hasPeerParam = !!searchParams?.get("peerId")
        if (currentThreadParam !== normalizedThreadId || hasPeerParam) {
          const nextParams = new URLSearchParams(searchParams?.toString() ?? "")
          nextParams.set("thread", normalizedThreadId)
          nextParams.delete("peerId")
          const queryString = nextParams.toString()
          router.replace(queryString ? `${pathname}?${queryString}` : pathname, { scroll: false })
        }
      })

      // Fetch messages in background - don't block UI
      try {
        const response = await fetch(`/api/dm/threads/${normalizedThreadId}/messages?limit=${DEFAULT_PAGE_SIZE}`, {
          cache: "no-store",
          signal: abortController.signal, // Allow cancellation if user switches quickly
        })
        
        // Check if request was aborted
        if (abortController.signal.aborted) {
          return
        }
        
        if (!response.ok) throw new Error("Failed to load messages")
        const data = await response.json()
        const fetchedMessages: MessageResult[] = data.messages ?? []
        
        // Check again if request was aborted before updating state
        if (abortController.signal.aborted) {
          return
        }
        
        // Update messages state using startTransition for non-blocking update
        startTransition(() => {
          setMessagesByThread((prev) => ({
            ...prev,
            [normalizedThreadId]: fetchedMessages,
          }))
          setThreadPagination((prev) => ({
            ...prev,
            [normalizedThreadId]: {
              hasMore: Boolean(data.pageInfo?.hasMore),
              nextCursor: data.pageInfo?.nextCursor ?? null,
            },
          }))
          setLoadingThreadId(null)
        })
        
        // Ensure attachment URLs in background - don't block
        ensureAttachmentUrls(fetchedMessages.flatMap((m) => m.attachments ?? [])).catch((error) => {
          console.error("Error ensuring attachment URLs:", error)
          // Non-critical error - don't show toast
        })
      } catch (error: any) {
        // Ignore abort errors
        if (error.name === 'AbortError') {
          return
        }
        console.error(error)
        if (!abortController.signal.aborted) {
          setLoadingThreadId(null)
          toast.error("We couldn't load that conversation right now.")
        }
      }
    },
    [ensureAttachmentUrls, isMobile, pathname, router, searchParams],
  )

  const handleMarkThreadRead = useCallback(
    async (threadId: string) => {
      try {
        await fetch(`/api/dm/threads/${threadId}/read`, { method: "POST" })
        setConversations((prev) =>
          prev.map((item) =>
            item.thread_id === threadId
              ? {
                  ...item,
                  last_read_at: new Date().toISOString(),
                }
              : item,
          ),
        )
      } catch (error) {
        console.error(error)
      }
    },
    [],
  )

  useEffect(() => {
    const params = searchParams
    if (!params) return

    const peerParam = params.get("peerId")
    if (peerParam) {
      return
    }

    const threadParam = params.get("thread")?.trim()
    if (!threadParam || threadParam === selectedThreadId || lastThreadFromQueryRef.current === threadParam) {
      return
    }

    let cancelled = false

    const selectFromQuery = async () => {
      try {
        let conversation = conversationsRef.current.find((item) => item.thread_id === threadParam)
        if (!conversation) {
          try {
            const refreshed = await refreshConversations()
            if (cancelled) return
            conversation = refreshed.find((item) => item.thread_id === threadParam)
          } catch (error) {
            console.error(error)
          }
        }

        if (cancelled) return

        if (conversation) {
          // Set mobile view to conversation when opening from query parameter
          if (typeof window !== "undefined" && window.innerWidth < 1024) {
            setMobileView("conversation")
          }
          await handleSelectConversation(threadParam)
          if (!cancelled) {
            lastThreadFromQueryRef.current = threadParam
          }
        }
      } catch (error) {
        if (!cancelled) {
          console.error(error)
        }
      }
    }

    selectFromQuery()

    return () => {
      cancelled = true
    }
  }, [handleSelectConversation, refreshConversations, searchParams, selectedThreadId])

  useEffect(() => {
    const params = searchParams
    if (!params) return

    const peerParam = params.get("peerId")?.trim()
    if (!peerParam) return

    let cancelled = false

    const openFromPeer = async () => {
      try {
        const response = await fetch("/api/dm/threads", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ peerUserId: peerParam }),
        })

        if (!response.ok) {
          throw new Error("Failed to open conversation")
        }

        const data = await response.json()
        const threadId: string | undefined = data?.thread?.id ?? data?.threadId
        if (!threadId) {
          throw new Error("Conversation unavailable")
        }

        if (!conversationsRef.current.some((item) => item.thread_id === threadId)) {
          try {
            await refreshConversations()
            if (cancelled) return
          } catch (error) {
            console.error(error)
          }
        }

        if (cancelled) return

        const nextParams = new URLSearchParams(params.toString())
        nextParams.set("thread", threadId)
        nextParams.delete("peerId")
        const queryString = nextParams.toString()
        router.replace(queryString ? `${pathname}?${queryString}` : pathname, { scroll: false })

        // Set mobile view to conversation when opening from peerId
        if (typeof window !== "undefined" && window.innerWidth < 1024) {
          setMobileView("conversation")
        }
        await handleSelectConversation(threadId)
        if (!cancelled) {
          lastThreadFromQueryRef.current = threadId
        }
      } catch (error) {
        if (!cancelled) {
          console.error(error)
          toast.error("Unable to open conversation right now.")
        }
      }
    }

    openFromPeer()

    return () => {
      cancelled = true
    }
  }, [handleSelectConversation, pathname, refreshConversations, router, searchParams])

  // Mark messages as read when viewing them
  const markMessagesAsRead = useCallback(async (threadId: string, messageIds: string[]) => {
    if (messageIds.length === 0) return
    
    try {
      const response = await fetch(`/api/dm/threads/${threadId}/messages/read`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ messageIds }),
      })

      if (!response.ok) {
        throw new Error("Failed to mark messages as read")
      }

      // Update read receipts in local state
      setMessagesByThread((prev) => {
        const messages = prev[threadId] ?? []
        const now = new Date().toISOString()
        const otherUserId = selectedConversation?.other_user_id
        
        return {
          ...prev,
          [threadId]: messages.map((msg) => {
            // Only update read receipts for messages sent by the other user
            if (msg.sender_id !== viewer.id && messageIds.includes(msg.id) && otherUserId) {
              const existingReceipt = msg.read_receipts?.find((r) => r.user_id === viewer.id)
              if (!existingReceipt) {
                return {
                  ...msg,
                  read_receipts: [
                    ...(msg.read_receipts ?? []),
                    {
                      id: `temp-${msg.id}-${viewer.id}`,
                      message_id: msg.id,
                      user_id: viewer.id,
                      read_at: now,
                    },
                  ],
                }
              }
            }
            return msg
          }),
        }
      })
    } catch (error) {
      console.error("[markMessagesAsRead] Error:", error)
    }
  }, [viewer.id, selectedConversation])

  useEffect(() => {
    if (!selectedConversation || !selectedThreadId) return
    
    // Only mark messages as read if the conversation is actively being viewed
    // On mobile, check if we're in conversation view (not list view)
    if (isMobile && mobileView !== "conversation") {
      return
    }
    
    const lastMessageAt = selectedConversation.last_message_at
    const lastReadAt = selectedConversation.last_read_at
    const unread =
      lastMessageAt && (!lastReadAt || new Date(lastMessageAt).getTime() > new Date(lastReadAt).getTime())

    if (unread) {
      handleMarkThreadRead(selectedThreadId)
    }

    // Mark all unread messages from the other user as read
    const messages = messagesByThread[selectedThreadId] ?? []
    const unreadMessageIds = messages
      .filter((msg) => {
        // Only mark messages from the other user as read
        if (msg.sender_id === viewer.id) return false
        // Check if already read
        const isRead = msg.read_receipts?.some((r) => r.user_id === viewer.id)
        return !isRead
      })
      .map((msg) => msg.id)

    if (unreadMessageIds.length > 0) {
      markMessagesAsRead(selectedThreadId, unreadMessageIds)
    }
  }, [selectedConversation, selectedThreadId, handleMarkThreadRead, messagesByThread, viewer.id, markMessagesAsRead, isMobile, mobileView])

  const cleanupChannel = useCallback(() => {
    if (channelRef.current) {
      try {
        supabase.removeChannel(channelRef.current)
      } catch (error) {
        console.error("[cleanupChannel] Error removing channel:", error)
      } finally {
        channelRef.current = null
      }
    }
  }, [])

  const cleanupThreadsChannel = useCallback(() => {
    if (threadsChannelRef.current) {
      try {
        supabase.removeChannel(threadsChannelRef.current)
      } catch (error) {
        console.error("[cleanupThreadsChannel] Error removing channel:", error)
      } finally {
        threadsChannelRef.current = null
      }
    }
  }, [])

  useEffect(() => {
    cleanupChannel()
    if (!selectedThreadId || !selectedConversation) return

    // Create a dedicated channel for postgres_changes (separate from presence/broadcast)
    const messagesChannel = supabase
      .channel(`dm-messages-${selectedThreadId}`, {
        config: {
          broadcast: { self: false },
        },
      })
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "dm_messages",
          filter: `thread_id=eq.${selectedThreadId}`,
        },
        async (payload) => {
          try {
            console.log("[realtime] Received message INSERT event:", payload)
            
            if (!payload || !payload.new) {
              console.error("[realtime] Invalid payload structure:", payload)
              return
            }
            
            // Filter by thread_id in the handler instead of in the subscription
            const messageThreadId = (payload.new as { thread_id?: string })?.thread_id
            if (!messageThreadId) {
              console.error("[realtime] Message missing thread_id:", payload.new)
              return
            }
            
            if (messageThreadId !== selectedThreadId) {
              console.log("[realtime] Message is for different thread, ignoring:", messageThreadId, "expected:", selectedThreadId)
              return
            }
            
            console.log("[realtime] Processing message for current thread:", messageThreadId)
          
          const newMessage = payload.new as {
            id: string
            thread_id: string
            sender_id: string
            message_type: string
            content?: string | null
            metadata?: Record<string, unknown> | null
            has_attachments: boolean
            reply_to_message_id?: string | null
            created_at: string
            updated_at: string
            is_deleted: boolean
          }
          
          if (!newMessage || !newMessage.id) {
            console.error("[realtime] Invalid message payload:", payload)
            return
          }

          // Skip if this is our own message - it's already added optimistically
          if (newMessage.sender_id === viewer.id) {
            console.log("[realtime] Skipping own message:", newMessage.id)
            return
          }

          console.log("[realtime] Processing new message from other user:", newMessage.id, "in thread:", selectedThreadId)

          // Immediately stop typing indicator when a message is received
          setTypingIndicators((prev) => {
            const next = { ...prev }
            delete next[selectedThreadId]
            return next
          })
          // Clear any pending typing display timeout
          if (typingDisplayTimeoutRef.current[selectedThreadId]) {
            clearTimeout(typingDisplayTimeoutRef.current[selectedThreadId])
            delete typingDisplayTimeoutRef.current[selectedThreadId]
          }
          // Immediately hide typing indicator
          setDisplayTypingIndicators((prev) => {
            const next = { ...prev }
            delete next[selectedThreadId]
            return next
          })

          // Fetch attachments, read receipts, and replied-to message in parallel
          const [attachmentsResult, readReceiptsResult, repliedToResult] = await Promise.all([
            supabase
              .from("dm_message_media")
              .select("id, message_id, media_type, storage_path, mime_type, file_size, duration_seconds, file_name, created_at, source_storage_path, source_bucket")
              .eq("message_id", newMessage.id),
            supabase
              .from("dm_message_reads")
              .select("id, message_id, user_id, read_at")
              .eq("message_id", newMessage.id),
            newMessage.reply_to_message_id
              ? Promise.all([
                  supabase
                    .from("dm_messages")
                    .select("id, sender_id, content, has_attachments, created_at, thread_id, is_deleted")
                    .eq("id", newMessage.reply_to_message_id)
                    .eq("thread_id", selectedThreadId) // Ensure same thread
                    .eq("is_deleted", false) // Ensure not deleted
                    .maybeSingle(),
                  supabase
                    .from("dm_message_media")
                    .select("id, message_id, media_type, storage_path, mime_type, file_size, duration_seconds, file_name, created_at, source_storage_path, source_bucket")
                    .eq("message_id", newMessage.reply_to_message_id),
                ]).then(([messageResult, attachmentsResult]) => ({
                  data: messageResult.data
                    ? {
                        ...messageResult.data,
                        attachments: attachmentsResult.data ?? [],
                      }
                    : null,
                  error: messageResult.error || attachmentsResult.error || null,
                }))
              : Promise.resolve({ data: null, error: null }),
          ])

          // If this is a boost reward message with attachments that need copying, copy them
          if (newMessage.metadata?.boost_reward && attachmentsResult.data) {
            const needsCopying = attachmentsResult.data.some((a: any) => a.source_storage_path && a.source_bucket)
            if (needsCopying) {
              // Copy files from post-media to dm-media bucket
              fetch("/api/dm/copy-boost-attachments", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ messageId: newMessage.id }),
              }).catch((error) => {
                console.error("Error copying boost reward attachments:", error)
              })
            }
          }

          const enrichedMessage: MessageResult = {
            id: newMessage.id,
            thread_id: newMessage.thread_id,
            sender_id: newMessage.sender_id,
            message_type: newMessage.message_type as "text" | "system",
            content: newMessage.content ?? null,
            metadata: newMessage.metadata ?? null,
            has_attachments: newMessage.has_attachments ?? false,
            reply_to_message_id: newMessage.reply_to_message_id ?? null,
            created_at: newMessage.created_at,
            updated_at: newMessage.updated_at,
            is_deleted: newMessage.is_deleted ?? false,
            attachments: attachmentsResult.data ?? [],
            read_receipts: readReceiptsResult.data ?? [],
            replied_to_message: repliedToResult.data &&
              repliedToResult.data.thread_id === selectedThreadId &&
              !repliedToResult.data.is_deleted
              ? {
                  id: repliedToResult.data.id,
                  sender_id: repliedToResult.data.sender_id,
                  content: repliedToResult.data.content ?? null,
                  has_attachments: repliedToResult.data.has_attachments ?? false,
                  created_at: repliedToResult.data.created_at,
                  attachments: (repliedToResult.data as any).attachments ?? [],
                }
              : null,
          }

          // Add message to state (append since messages are in ascending order)
          setMessagesByThread((prev) => {
            const existingMessages = prev[selectedThreadId] ?? []
            // Check if message already exists (race condition protection)
            if (existingMessages.some((message) => message.id === enrichedMessage.id)) {
              console.log("[realtime] Message already exists, skipping:", enrichedMessage.id)
              return prev
            }
            console.log("[realtime] Adding new message to state:", enrichedMessage.id, "Total messages:", existingMessages.length + 1)
            // Append new message to the end (messages are in ascending chronological order)
            return {
              ...prev,
              [selectedThreadId]: [...existingMessages, enrichedMessage],
            }
          })

          const hasImage = enrichedMessage.attachments?.some(a => a.media_type === "image") ?? false
          setConversations((prev) =>
            prev
              .map((item) =>
                item.thread_id === selectedThreadId
                  ? {
                      ...item,
                      last_message_at: enrichedMessage.created_at,
                      last_message_preview: enrichedMessage.content ?? (hasImage ? "[image]" : (enrichedMessage.attachments?.length ? "[attachment]" : "")),
                      last_message_sender_id: enrichedMessage.sender_id,
                      updated_at: new Date().toISOString(),
                    }
                  : item,
              )
              .sort((a, b) => {
                const aTime = new Date(a.last_message_at ?? a.updated_at).getTime()
                const bTime = new Date(b.last_message_at ?? b.updated_at).getTime()
                return bTime - aTime
              }),
          )

          ensureAttachmentUrls(enrichedMessage.attachments ?? [])

          // Mark message as read if viewing this thread and conversation is actively open
          // On mobile, only mark if in conversation view (not list view)
          // Use refs to avoid stale closure values
          const currentThreadId = selectedThreadIdRef.current
          const currentMobileView = mobileViewRef.current
          const currentIsMobile = isMobileRef.current
          const isConversationActive = !currentIsMobile || currentMobileView === "conversation"
          if (currentThreadId === newMessage.thread_id && isConversationActive) {
            markMessagesAsRead(currentThreadId, [enrichedMessage.id]).catch((error) => {
              console.error("[realtime] Failed to mark message as read:", error)
            })
          }
          } catch (error) {
            console.error("[realtime] Error processing message INSERT event:", error, payload)
          }
        },
      )
      .subscribe(async (status, err) => {
        console.log("[messagesChannel.subscribe] Channel status:", status, "for thread:", selectedThreadId)
        if (err) {
          console.error("[messagesChannel.subscribe] Subscription error:", err)
        }
        if (status === "SUBSCRIBED") {
          console.log("[messagesChannel.subscribe] Successfully subscribed to messages for thread:", selectedThreadId)
        }
      })

    // Create a separate channel for presence and typing (broadcast events)
    const channel = supabase
      .channel(getThreadChannelName(selectedThreadId), {
        config: {
          presence: {
            key: viewer.id,
          },
        },
      })
      .on(
        "presence",
        { event: "sync" },
        () => {
          const state = channel.presenceState<{ userId: string }>()
          const otherUserId = selectedConversation.other_user_id
          const otherIsPresent = Object.values(state).some((entries) =>
            entries.some((item) => item.userId === otherUserId),
          )
          setPresenceMap((prev) => ({
            ...prev,
            [selectedThreadId]: otherIsPresent,
          }))
        },
      )
      .on("broadcast", { event: DM_TYPING_EVENT }, ({ payload }) => {
        if (!payload) return
        const { userId, typing } = payload as { userId: string; typing: boolean }
        if (!userId || userId === viewer.id) return
        setTypingIndicators((prev) => {
          const expiresAt = Date.now() + TYPING_EXPIRATION_MS
          const next = { ...prev }
          if (typing) {
            next[selectedThreadId] = { userId, expiresAt }
          } else {
            delete next[selectedThreadId]
          }
          return next
        })
      })
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "dm_message_reads",
        },
        async (payload) => {
          try {
            console.log("[realtime] Received read receipt INSERT event:", payload)
            
            const readReceipt = payload.new as {
              id: string
              message_id: string
              user_id: string
              read_at: string
            }
            if (!readReceipt || !readReceipt.message_id) {
              console.error("[realtime] Invalid read receipt payload:", payload)
              return
            }

            // Get current thread ID from ref to avoid stale closure
            const currentThreadId = selectedThreadIdRef.current
            if (!currentThreadId) {
              console.log("[realtime] No thread selected, ignoring read receipt")
              return
            }

            // Fetch the message to get its thread_id
            const { data: messageData, error: messageError } = await supabase
              .from("dm_messages")
              .select("thread_id, sender_id")
              .eq("id", readReceipt.message_id)
              .single()

            if (messageError || !messageData) {
              console.error("[realtime] Error fetching message for read receipt:", messageError)
              return
            }

            const messageThreadId = messageData.thread_id
            if (messageThreadId !== currentThreadId) {
              console.log("[realtime] Read receipt is for different thread, ignoring:", messageThreadId, "expected:", currentThreadId)
              return
            }

            // Only update if this read receipt is for a message we sent
            if (messageData.sender_id !== viewer.id) {
              console.log("[realtime] Read receipt is not for our message, ignoring")
              return
            }

            console.log("[realtime] Processing read receipt for message:", readReceipt.message_id, "in thread:", currentThreadId)

            // Update the message with the new read receipt using functional update
            setMessagesByThread((prev) => {
              const threadMessages = prev[currentThreadId] ?? []
              const messageExists = threadMessages.some((msg) => msg.id === readReceipt.message_id)
              
              if (!messageExists) {
                console.log("[realtime] Message not found in current thread, skipping read receipt update")
                return prev
              }

              let updated = false
              const updatedMessages = threadMessages.map((msg) => {
                if (msg.id === readReceipt.message_id) {
                  const existingReceipt = msg.read_receipts?.find(
                    (r) => r.id === readReceipt.id || (r.message_id === readReceipt.message_id && r.user_id === readReceipt.user_id)
                  )
                  if (!existingReceipt) {
                    console.log("[realtime] Adding read receipt to message:", readReceipt.message_id)
                    updated = true
                    return {
                      ...msg,
                      read_receipts: [...(msg.read_receipts ?? []), readReceipt],
                    }
                  } else {
                    console.log("[realtime] Read receipt already exists, skipping")
                  }
                }
                return msg
              })

              if (!updated) {
                return prev
              }

              return {
                ...prev,
                [currentThreadId]: updatedMessages,
              }
            })
          } catch (error) {
            console.error("[realtime] Error processing read receipt INSERT event:", error, payload)
          }
        },
      )
      .subscribe(async (status, err) => {
        console.log("[channel.subscribe] Presence/typing channel status:", status, "for thread:", selectedThreadId)
        if (err) {
          console.error("[channel.subscribe] Subscription error:", err)
        }
        if (status === "SUBSCRIBED") {
          console.log("[channel.subscribe] Successfully subscribed to presence/typing for thread:", selectedThreadId)
          try {
            await channel.track({ userId: viewer.id, at: Date.now() })
            console.log("[channel.subscribe] Presence tracked for user:", viewer.id)
          } catch (error) {
            console.error("[channel.subscribe] Failed to track presence:", error)
          }
        } else if (status === "CHANNEL_ERROR") {
          console.error("[channel.subscribe] Channel error detected, will attempt reconnect")
        } else if (status === "TIMED_OUT") {
          console.error("[channel.subscribe] Channel timed out")
        } else if (status === "CLOSED") {
          console.warn("[channel.subscribe] Channel closed")
        }
      })

    // Store both channels
    channelRef.current = channel
    messagesChannelRef.current = messagesChannel

    return () => {
      cleanupChannel()
      // Also cleanup messages channel
      if (messagesChannelRef.current) {
        try {
          supabase.removeChannel(messagesChannelRef.current)
        } catch (error) {
          console.error("[cleanupMessagesChannel] Error removing messages channel:", error)
        } finally {
          messagesChannelRef.current = null
        }
      }
    }
  }, [cleanupChannel, ensureAttachmentUrls, markMessagesAsRead, selectedConversation, selectedThreadId, viewer.id])

  // Subscribe to dm_threads updates to refresh conversation previews when messages change
  useEffect(() => {
    cleanupThreadsChannel()

    const threadsChannel = supabase
      .channel("dm-threads-updates", {
        config: {
          broadcast: { self: false },
        },
      })
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "dm_threads",
        },
        async (payload) => {
          const updatedThread = payload.new as {
            id: string
            last_message_at: string | null
            last_message_preview: string | null
            last_message_sender_id: string | null
            updated_at: string
          }

          if (!updatedThread) return

          // Check if this thread is in our conversations list
          const existingConversation = conversationsRef.current.find(
            (c) => c.thread_id === updatedThread.id
          )

          if (!existingConversation) {
            // Thread not in our list, might be a new conversation - refresh the list
            refreshConversations().catch((error) => {
              console.error("[threadsChannel] Error refreshing conversations:", error)
            })
            return
          }

          // Update the conversation in our list with the new preview
          setConversations((prev) =>
            prev
              .map((item) =>
                item.thread_id === updatedThread.id
                  ? {
                      ...item,
                      last_message_at: updatedThread.last_message_at,
                      last_message_preview: updatedThread.last_message_preview,
                      last_message_sender_id: updatedThread.last_message_sender_id,
                      updated_at: updatedThread.updated_at,
                    }
                  : item,
              )
              .sort((a, b) => {
                const aTime = new Date(a.last_message_at ?? a.updated_at).getTime()
                const bTime = new Date(b.last_message_at ?? b.updated_at).getTime()
                return bTime - aTime
              }),
          )

          // If this thread has messages loaded, also update liveMessagePreviews
          if (messagesRef.current[updatedThread.id]) {
            // Fetch the actual last message to ensure preview is accurate
            const { data: lastMessageData } = await supabase
              .from("dm_messages")
              .select("id, content, created_at, sender_id")
              .eq("thread_id", updatedThread.id)
              .order("created_at", { ascending: false })
              .limit(1)
              .maybeSingle()

            if (lastMessageData) {
              const { data: attachmentsData } = await supabase
                .from("dm_message_media")
                .select("id")
                .eq("message_id", lastMessageData.id)
                .limit(1)

              const hasAttachments = (attachmentsData?.length ?? 0) > 0
              const previewContent =
                lastMessageData.content ?? (hasAttachments ? "[attachment]" : "")

              // Update messagesByThread if the last message changed
              setMessagesByThread((prev) => {
                const existingMessages = prev[updatedThread.id] ?? []
                if (existingMessages.length === 0) return prev

                const currentLast = existingMessages[existingMessages.length - 1]
                if (currentLast.id === lastMessageData.id) {
                  // Same message, just update the preview in conversations
                  return prev
                }

                // Last message changed (might have been deleted), refresh messages for this thread
                // This will be handled by the user opening the thread or by prefetch
                return prev
              })
            }
          }
        },
      )
      .subscribe((status) => {
        if (status === "SUBSCRIBED") {
          // Channel subscribed successfully
        } else if (status === "CHANNEL_ERROR") {
          console.error("[threadsChannel] Channel error detected")
        } else if (status === "TIMED_OUT") {
          console.error("[threadsChannel] Channel timed out")
        }
      })

    threadsChannelRef.current = threadsChannel

    return () => {
      cleanupThreadsChannel()
    }
  }, [cleanupThreadsChannel, refreshConversations])

  useEffect(() => {
    if (!selectedThreadId) return
    if (!typingIndicators[selectedThreadId]) return

    const timeout = setTimeout(() => {
      setTypingIndicators((prev) => {
        const current = prev[selectedThreadId]
        if (!current) return prev
        if (Date.now() < current.expiresAt) return prev
        const next = { ...prev }
        delete next[selectedThreadId]
        return next
      })
    }, TYPING_EXPIRATION_MS)

    return () => clearTimeout(timeout)
  }, [selectedThreadId, typingIndicators])

  // Add grace period for typing indicator display (prevents flicker on brief pauses)
  // Note: Grace period only applies if typing stops without a message being sent
  // If a message is sent, the typing indicator is cleared immediately in the message handler
  useEffect(() => {
    if (!selectedThreadId) return

    const isTyping = !!typingIndicators[selectedThreadId]

    if (isTyping) {
      // Show immediately when typing starts
      setDisplayTypingIndicators((prev) => ({
        ...prev,
        [selectedThreadId]: true,
      }))
      
      // Clear any pending hide timeout
      if (typingDisplayTimeoutRef.current[selectedThreadId]) {
        clearTimeout(typingDisplayTimeoutRef.current[selectedThreadId])
        delete typingDisplayTimeoutRef.current[selectedThreadId]
      }
    } else {
      // Only apply grace period if typing stopped (not if message was sent)
      // Use a ref to check current state without causing re-renders
      setDisplayTypingIndicators((prev) => {
        const isCurrentlyDisplayed = prev[selectedThreadId]
        if (isCurrentlyDisplayed) {
          // Keep showing for 2 more seconds after typing stops (grace period)
          // Clear any existing timeout first
          if (typingDisplayTimeoutRef.current[selectedThreadId]) {
            clearTimeout(typingDisplayTimeoutRef.current[selectedThreadId])
          }
          const timeout = setTimeout(() => {
            setDisplayTypingIndicators((current) => {
              const next = { ...current }
              delete next[selectedThreadId]
              return next
            })
            delete typingDisplayTimeoutRef.current[selectedThreadId]
          }, 2000)
          
          typingDisplayTimeoutRef.current[selectedThreadId] = timeout
        }
        return prev
      })
    }

    return () => {
      if (typingDisplayTimeoutRef.current[selectedThreadId]) {
        clearTimeout(typingDisplayTimeoutRef.current[selectedThreadId])
        delete typingDisplayTimeoutRef.current[selectedThreadId]
      }
    }
  }, [selectedThreadId, typingIndicators])

  // Function to scroll to a message and highlight it
  const scrollToMessage = useCallback(async (messageId: string) => {
    const normalizedThreadId = selectedThreadId?.trim()
    if (!normalizedThreadId) return

    // Check if message exists in current messages
    const currentMessages = messagesByThread[normalizedThreadId] ?? []
    const messageExists = currentMessages.some(m => m.id === messageId)
    
    // If message doesn't exist and there are more messages to load, load them
    if (!messageExists) {
      const pagination = threadPagination[normalizedThreadId]
      if (pagination?.hasMore && !loadingOlderMessages) {
        // Load older messages until we find the target message or run out of messages
        let found = false
        let hasMore: boolean = pagination.hasMore
        let nextCursor = pagination.nextCursor
        let loadAttempts = 0
        const MAX_LOAD_ATTEMPTS = 20 // Safety limit to prevent infinite loops
        
        while (!found && hasMore && !loadingOlderMessages && loadAttempts < MAX_LOAD_ATTEMPTS) {
          loadAttempts++
          try {
            setLoadingOlderMessages(true)
            const params = new URLSearchParams()
            params.set("limit", String(DEFAULT_PAGE_SIZE))
            if (nextCursor) {
              params.set("before", nextCursor)
            }

            const response = await fetch(`/api/dm/threads/${normalizedThreadId}/messages?${params.toString()}`, {
              cache: "no-store",
            })
            if (!response.ok) {
              throw new Error("Failed to load older messages")
            }
            const data = await response.json()
            const fetchedMessages: MessageResult[] = data.messages ?? []
            
            // Check if target message is in fetched messages
            found = fetchedMessages.some(m => m.id === messageId)
            
            setMessagesByThread((prev) => ({
              ...prev,
              [normalizedThreadId]: [...fetchedMessages, ...(prev[normalizedThreadId] ?? [])],
            }))
            
            hasMore = Boolean(data.pageInfo?.hasMore)
            nextCursor = data.pageInfo?.nextCursor ?? null
            
            setThreadPagination((prev) => ({
              ...prev,
              [normalizedThreadId]: {
                hasMore,
                nextCursor,
              },
            }))
            
            ensureAttachmentUrls(fetchedMessages.flatMap((m) => m.attachments ?? []))
            
            // Wait a bit for DOM to update
            await new Promise(resolve => setTimeout(resolve, 100))
          } catch (error) {
            console.error("Error loading older messages:", error)
            setLoadingOlderMessages(false)
            return
          } finally {
            setLoadingOlderMessages(false)
          }
        }
      }
    }

    // Now try to scroll to the message
    const attemptScroll = () => {
      const messageElement = messageRefs.current.get(messageId)
      const container = messageContainerRef.current
      
      if (!messageElement || !container) {
        // If still not found, try again after a short delay
        setTimeout(() => {
          attemptScroll()
        }, 100)
        return
      }
      
      // Highlight the message first
      setHighlightedMessageId(messageId)
      highlightedMessageIdRef.current = messageId
      
      // Use requestAnimationFrame to ensure DOM is updated before scrolling
      requestAnimationFrame(() => {
        // Scroll to message with better positioning
        messageElement.scrollIntoView({ 
          behavior: "smooth", 
          block: "center",
          inline: "nearest"
        })
        
        // Also try scrolling the container if needed (for better centering)
        setTimeout(() => {
          const elementRect = messageElement.getBoundingClientRect()
          const containerRect = container.getBoundingClientRect()
          const elementCenter = elementRect.top + elementRect.height / 2
          const containerCenter = containerRect.top + containerRect.height / 2
          const scrollOffset = elementCenter - containerCenter
          
          if (Math.abs(scrollOffset) > 10) {
            container.scrollBy({
              top: scrollOffset,
              behavior: "smooth"
            })
          }
        }, 100)
      })
      
      // Remove highlight after 2 seconds
      setTimeout(() => {
        setHighlightedMessageId(null)
        highlightedMessageIdRef.current = null
      }, 2000)
    }
    
    // Wait a bit for DOM to update after loading messages
    setTimeout(() => {
      attemptScroll()
    }, 150)
  }, [selectedThreadId, messagesByThread, threadPagination, loadingOlderMessages, ensureAttachmentUrls])

  const notifyTyping = useCallback(
    (typing: boolean) => {
      if (!channelRef.current) return
      channelRef.current.send({
        type: "broadcast",
        event: DM_TYPING_EVENT,
        payload: {
          userId: viewer.id,
          typing,
        },
      })
    },
    [viewer.id],
  )

  const scheduleTypingBroadcast = useCallback(() => {
    if (typingBroadcastCooldownRef.current) return
    notifyTyping(true)
    typingBroadcastCooldownRef.current = setTimeout(() => {
      typingBroadcastCooldownRef.current = null
      notifyTyping(false)
    }, TYPING_EXPIRATION_MS)
  }, [notifyTyping])

  // Handle emoji selection
  const handleEmojiSelect = useCallback((emoji: string) => {
    if (!textareaRef.current) return
    
    const textarea = textareaRef.current
    // Focus the textarea first to ensure selection is valid
    textarea.focus()
    
    // Get cursor position (default to end if no selection)
    const start = textarea.selectionStart ?? composerValue.length
    const end = textarea.selectionEnd ?? composerValue.length
    const textBefore = composerValue.substring(0, start)
    const textAfter = composerValue.substring(end)
    
    const newValue = textBefore + emoji + textAfter
    setComposerValue(newValue)
    
    // Set cursor position after the inserted emoji
    setTimeout(() => {
      if (textareaRef.current) {
        const newCursorPosition = start + emoji.length
        textareaRef.current.setSelectionRange(newCursorPosition, newCursorPosition)
        textareaRef.current.focus()
      }
    }, 0)
  }, [composerValue])

  // Auto-resize textarea based on content
  const autoResizeTextarea = useCallback(() => {
    const textarea = textareaRef.current
    if (!textarea) return

    // Reset height to auto to get the correct scrollHeight
    textarea.style.height = "auto"
    // Set height to scrollHeight, but respect max-height
    const scrollHeight = textarea.scrollHeight
    // Calculate max-height based on breakpoint (sm is 640px)
    const isSmallScreen = typeof window !== "undefined" && window.innerWidth < 640
    const maxHeight = isSmallScreen ? 96 : 128 // max-h-24 (96px) or sm:max-h-32 (128px)
    // Min height should account for padding (4px top + 4px bottom = 8px) plus text height
    const minHeight = 32 // Adjusted to better align with buttons
    const newHeight = Math.min(Math.max(scrollHeight, minHeight), maxHeight)
    textarea.style.height = `${newHeight}px`
  }, [])

  const resetComposer = useCallback(() => {
      setComposerValue("")
      setReplyingToMessage(null)
      setAttachments((prev) => {
        prev.forEach((attachment) => {
          if (attachment.previewUrl) URL.revokeObjectURL(attachment.previewUrl)
        })
        return []
      })
      // Reset textarea height after clearing
      setTimeout(() => {
        autoResizeTextarea()
      }, 0)
  }, [autoResizeTextarea])

  // Auto-resize textarea on mount and when composer value changes
  useEffect(() => {
    autoResizeTextarea()
  }, [composerValue, autoResizeTextarea])

  const handleComposerChange = useCallback(
    (value: string) => {
      setComposerValue(value)
      scheduleTypingBroadcast()
      if (typingTimeoutRef.current) clearTimeout(typingTimeoutRef.current)
      typingTimeoutRef.current = setTimeout(() => {
        notifyTyping(false)
      }, TYPING_DEBOUNCE_MS)
      
      // Auto-resize textarea after state update
      setTimeout(() => {
        autoResizeTextarea()
      }, 0)
    },
    [notifyTyping, scheduleTypingBroadcast, autoResizeTextarea],
  )

  // Map file extensions to MIME types
  const getMimeTypeFromExtension = useCallback((extension: string, detectedType: string | undefined, mediaType: AttachmentState["mediaType"]): string => {
    const extensionMap: Record<string, string> = {
      // Images - All major formats
      jpg: "image/jpeg",
      jpeg: "image/jpeg",
      png: "image/png",
      webp: "image/webp",
      gif: "image/gif",
      bmp: "image/bmp",
      svg: "image/svg+xml",
      tiff: "image/tiff",
      tif: "image/tiff",
      ico: "image/x-icon",
      heic: "image/heic",
      heif: "image/heif",
      avif: "image/avif",
      // Audio
      ogg: "audio/ogg",
      mp3: "audio/mpeg",
      mpeg: "audio/mpeg",
      wav: "audio/wav",
      aac: "audio/aac",
      flac: "audio/flac",
      m4a: "audio/mp4",
      opus: "audio/opus",
      // Documents
      pdf: "application/pdf",
      doc: "application/msword",
      docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      xls: "application/vnd.ms-excel",
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      ppt: "application/vnd.ms-powerpoint",
      pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      txt: "text/plain",
      rtf: "application/rtf",
      // Videos
      mp4: "video/mp4",
      webm: "video/webm",
      mov: "video/quicktime",
      avi: "video/x-msvideo",
      mkv: "video/x-matroska",
      m4v: "video/x-m4v",
    }
    
    const ext = extension.toLowerCase()
    const mimeFromExtension = extensionMap[ext]
    
    // ALWAYS prioritize extension-based detection for known extensions
    // This prevents browser misdetection (e.g., detecting images as application/json)
    if (mimeFromExtension) {
      console.log(`[MIME Detection] Using extension-based MIME type: ${mimeFromExtension} (ext: ${ext}, detected: ${detectedType || "none"})`)
      return mimeFromExtension
    }
    
    // If no extension mapping, try to use detected type if it's valid
    if (detectedType && detectedType !== "application/json" && detectedType !== "application/octet-stream") {
      // Check if detected type is valid for the media type
      if (mediaType === "image" && detectedType.startsWith("image/")) {
        console.log(`[MIME Detection] Using detected image MIME type: ${detectedType}`)
        return detectedType
      }
      if (mediaType === "audio" && detectedType.startsWith("audio/")) {
        console.log(`[MIME Detection] Using detected audio MIME type: ${detectedType}`)
        return detectedType
      }
      if (mediaType === "video" && detectedType.startsWith("video/")) {
        console.log(`[MIME Detection] Using detected video MIME type: ${detectedType}`)
        return detectedType
      }
      if (mediaType === "file" && (detectedType.startsWith("application/") || detectedType.startsWith("text/"))) {
        console.log(`[MIME Detection] Using detected document MIME type: ${detectedType}`)
        return detectedType
      }
      if (detectedType === "application/pdf") {
        console.log(`[MIME Detection] Using detected PDF MIME type: ${detectedType}`)
        return detectedType
      }
    }
    
    // Default based on media type as last resort
    console.warn(`[MIME Detection] No extension mapping found, using default for media type: ${mediaType}`)
    if (mediaType === "image") {
      return "image/jpeg" // Default to JPEG for images
    }
    if (mediaType === "audio") {
      return "audio/webm" // Default to WebM for audio
    }
    if (mediaType === "video") {
      return "video/mp4" // Default to MP4 for video
    }
    if (mediaType === "file") {
      return "application/octet-stream" // Default for documents
    }
    
    return "application/octet-stream"
  }, [])

  const handleAddFiles = useCallback(
    async (files: File[] | null, mediaType: AttachmentState["mediaType"]) => {
      console.log('[handleAddFiles] CALLED with:', {
        filesCount: files?.length || 0,
        mediaType,
        currentAttachmentsCount: attachmentsRef.current.length,
        files: files?.map(f => ({ name: f.name, type: f.type, size: f.size }))
      })
      
      if (!files || files.length === 0) {
        console.log('[handleAddFiles] No files provided, returning early')
        return
      }
      
      const remainingSlots = MAX_ATTACHMENTS - attachmentsRef.current.length
      console.log('[handleAddFiles] Remaining slots:', remainingSlots)
      
      if (remainingSlots <= 0) {
        console.log('[handleAddFiles] No remaining slots, showing error')
        toast.error(`You can attach up to ${MAX_ATTACHMENTS} files per message.`)
        return
      }

      // Validate file sizes before processing
      const MAX_FILE_SIZE_VIDEO = 50 * 1024 * 1024 // 50MB for videos
      const MAX_FILE_SIZE_OTHER = 25 * 1024 * 1024 // 25MB for other file types
      
      const validFiles: File[] = []
      for (const file of files) {
        const maxSize = mediaType === "video" ? MAX_FILE_SIZE_VIDEO : MAX_FILE_SIZE_OTHER
        if (file.size > maxSize) {
          const maxSizeMB = mediaType === "video" ? 50 : 25
          const fileSizeMB = (file.size / 1024 / 1024).toFixed(2)
          toast.error(`${mediaType === "video" ? "Video" : "File"} "${file.name}" is too large (max ${maxSizeMB}MB). Your file is ${fileSizeMB}MB`)
          continue // Skip this file but continue with others
        }
        validFiles.push(file)
      }
      
      if (validFiles.length === 0) {
        console.log('[handleAddFiles] No valid files after size validation')
        return
      }

      const selected = validFiles.slice(0, remainingSlots)

      // Create all pending attachments first
      const pendingAttachments: AttachmentState[] = selected.map((file) => {
        const id = `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`
        // Create preview URL for images and videos immediately
        const previewUrl = (mediaType === "image" || mediaType === "video") ? URL.createObjectURL(file) : undefined

        return {
          id,
          fileName: file.name,
          mediaType,
          previewUrl: previewUrl || undefined, // Ensure it's explicitly set
          status: "uploading" as const,
        }
      })

      // Add all attachments at once so they show up immediately
      console.log('[handleAddFiles] About to call setAttachments with:', {
        pendingAttachmentsCount: pendingAttachments.length,
        pendingAttachments: pendingAttachments.map(a => ({
          id: a.id,
          fileName: a.fileName,
          mediaType: a.mediaType,
          status: a.status,
          hasPreviewUrl: !!a.previewUrl
        })),
        currentAttachmentsCount: attachments.length
      })
      
      setAttachments((prev) => {
        console.log('[handleAddFiles] setAttachments callback - prev state:', {
          prevCount: prev.length,
          prevAttachments: prev.map(a => ({ id: a.id, fileName: a.fileName }))
        })
        
        const updated = [...prev, ...pendingAttachments]
        // Update ref immediately
        attachmentsRef.current = updated
        
        console.log('[handleAddFiles] setAttachments callback - new state:', {
          updatedCount: updated.length,
          updatedAttachments: updated.map(a => ({
            id: a.id,
            fileName: a.fileName,
            mediaType: a.mediaType,
            status: a.status,
            hasPreviewUrl: !!a.previewUrl
          }))
        })
        
        return updated
      })
      
      console.log('[handleAddFiles] setAttachments called, attachments state should update')

      // Process each file for upload
      for (const file of selected) {
        const pendingAttachment = pendingAttachments.find(a => a.fileName === file.name)
        if (!pendingAttachment) continue

        try {
          // Extract file extension more robustly
          const fileName = file.name || "upload"
          const lastDotIndex = fileName.lastIndexOf(".")
          const extension = lastDotIndex > 0 && lastDotIndex < fileName.length - 1
            ? fileName.slice(lastDotIndex + 1).toLowerCase()
            : "bin"
          
          // Get MIME type from extension, validating against detected type
          const detectedMimeType = file.type || ""
          let mimeType = getMimeTypeFromExtension(extension, detectedMimeType, mediaType)
          
          // For JPG/JPEG files, ensure we use image/jpeg (standard MIME type)
          if ((extension === "jpg" || extension === "jpeg") && mimeType !== "image/jpeg") {
            console.warn(`[Message Upload] Correcting MIME type for ${fileName}: ${mimeType} -> image/jpeg`)
            mimeType = "image/jpeg"
          }
          
          // Validate MIME type is supported (client-side check)
          const allowedMimeTypes = [
            // Images - All major formats
            "image/jpeg", "image/jpg", "image/png", "image/webp", "image/gif", "image/bmp", 
            "image/svg+xml", "image/tiff", "image/x-icon", "image/ico",
            "image/heic", "image/heif", "image/avif",
            // Audio
            "audio/webm", "audio/ogg", "audio/mpeg", "audio/mp3", "audio/mp4",
            "audio/wav", "audio/aac", "audio/flac", "audio/opus",
            // Videos
            "video/mp4", "video/webm", "video/quicktime", "video/x-msvideo",
            "video/x-matroska", "video/x-m4v",
            // Documents
            "application/pdf", "application/msword",
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            "application/vnd.ms-excel",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "application/vnd.ms-powerpoint",
            "application/vnd.openxmlformats-officedocument.presentationml.presentation",
            "text/plain", "application/rtf"
          ]
          
          if (!allowedMimeTypes.includes(mimeType)) {
            throw new Error(`File type ${mimeType} is not supported. Supported formats: Images (JPEG, PNG, WebP, GIF, etc.), Audio (WebM, MP3, WAV, etc.), Video (MP4, WebM, MOV, etc.), or Documents (PDF, DOC, DOCX, etc.).`)
          }
          
          const { bucket, objectPath, storagePath } = buildDmMediaStoragePath(viewer.id, extension)
          
          console.log(`[Message Upload] Uploading file: ${fileName}, extension: ${extension}, detectedType: ${detectedMimeType}, mimeType: ${mimeType}, objectPath: ${objectPath}, fileSize: ${file.size}`)
          
          // Use the detected MIME type (should be image/jpeg for JPG files)
          const finalMimeType = mimeType
          
          // Upload options matching post upload pattern
          const uploadOptions = {
            contentType: finalMimeType,
            cacheControl: '0',
            upsert: false
          }
          
          console.log(`[Message Upload] Upload options:`, {
            ...uploadOptions,
            fileSize: file.size,
            fileName: file.name,
            fileTypeFromFile: file.type,
            detectedMimeType,
            finalMimeType,
          })
          
          // Upload the File directly (same pattern as posts) to preserve binary data integrity
          const { data: uploadData, error } = await supabase.storage
            .from(bucket)
            .upload(objectPath, file, uploadOptions)

          if (error) {
            // Log the complete error object to understand what's happening
            console.error(`[Message Upload] Upload error for ${fileName}:`, {
              error,
              errorMessage: error.message,
              errorName: error.name,
              errorStatus: (error as any).statusCode || (error as any).status || null,
              errorStack: error.stack,
              errorString: String(error),
              errorJSON: JSON.stringify(error, Object.getOwnPropertyNames(error)),
              uploadDetails: {
                fileName,
                extension,
                detectedMimeType,
                mimeType,
                finalMimeType,
                objectPath,
                fileSize: file.size,
                bucket,
                fileTypeFromFile: file.type,
              },
            })
            
            // Provide more specific error message based on the actual error
            let errorMessage = error.message || "Upload failed"
            
            // Check for MIME type errors - look for various error messages
            const errorMsg = error.message?.toLowerCase() || ""
            if (
              errorMsg.includes("mime type") || 
              errorMsg.includes("not supported") || 
              errorMsg.includes("allowed_mime_types") ||
              errorMsg.includes("content type") ||
              errorMsg.includes("invalid file type")
            ) {
              // This is a MIME type error from Supabase
              errorMessage = `File type "${finalMimeType}" is not supported. The storage bucket may need to be configured to accept ${finalMimeType} files. Detected: ${detectedMimeType || "unknown"}, Extension: ${extension}`
              console.error(`[Message Upload] MIME type validation failed. Sent: ${finalMimeType}, Detected: ${detectedMimeType}, Extension: ${extension}, Original file.type: ${file.type}`)
            } else if ((error as any).statusCode === "409" || (error as any).status === 409 || errorMsg.includes("already exists") || errorMsg.includes("duplicate")) {
              errorMessage = "File already exists"
            } else if ((error as any).statusCode === "413" || (error as any).status === 413 || errorMsg.includes("too large") || errorMsg.includes("file_size_limit") || errorMsg.includes("file size")) {
              const maxSizeMB = mediaType === "video" ? 50 : 25
              errorMessage = `File is too large (max ${maxSizeMB}MB for ${mediaType} files). Your file is ${(file.size / 1024 / 1024).toFixed(2)}MB`
            } else if ((error as any).statusCode === "403" || (error as any).status === 403 || errorMsg.includes("permission") || errorMsg.includes("forbidden") || errorMsg.includes("access denied")) {
              errorMessage = "Permission denied. Please check your account permissions."
            } else {
              // Use the exact error message from Supabase - this helps debug the actual issue
              errorMessage = error.message || "Upload failed"
            }
            
            throw new Error(errorMessage)
          }

          console.log(`[Message Upload] Successfully uploaded ${fileName} to ${objectPath}`)

          setAttachments((prev) =>
            prev.map((item) =>
              item.id === pendingAttachment.id
                ? {
                    ...item,
                    status: "ready",
                    storagePath,
                    objectPath,
                    mimeType: mimeType,
                    fileSize: file.size,
                    fileName: file.name, // Preserve original file name
                  }
                : item,
            ),
          )
        } catch (error: any) {
          console.error(`[Message Upload] Error uploading ${file.name}:`, error)
          const errorMessage = error?.message || error?.error?.message || "Upload failed"
          toast.error(`Failed to upload ${file.name}: ${errorMessage}`)
          setAttachments((prev) =>
            prev.map((item) =>
              item.id === pendingAttachment.id
                ? {
                    ...item,
                    status: "error",
                    error: errorMessage,
                  }
                : item,
            ),
          )
        }
      }
    },
    [viewer.id, getMimeTypeFromExtension],
  )

  const handleVoiceNoteComplete = useCallback(async (blob: Blob) => {
    const fileName = `voice-note-${Date.now()}.webm`
    const file = new File([blob], fileName, { type: "audio/webm" })
    await handleAddFiles([file], "audio")
    setIsVoiceRecorderOpen(false)
  }, [handleAddFiles])

  const handleVoiceNoteCancel = useCallback(() => {
    setIsVoiceRecorderOpen(false)
  }, [])

  const handleRemoveAttachment = useCallback((id: string) => {
    setAttachments((prev) => {
      const next = prev.filter((item) => item.id !== id)
      const removed = prev.find((item) => item.id === id)
      if (removed?.previewUrl) {
        URL.revokeObjectURL(removed.previewUrl)
      }
      return next
    })
  }, [])

  const handleSendMessage = useCallback(async () => {
    let normalizedThreadId = selectedThreadId?.trim() ?? ""
    if (!normalizedThreadId) {
      const fallbackThreadId =
        conversationsRef.current[0]?.thread_id?.trim() ??
        displayedConversations[0]?.thread_id?.trim() ??
        initialThreadId?.trim() ??
        ""

      if (!fallbackThreadId) {
        try {
          const refreshed = await refreshConversations()
          normalizedThreadId = refreshed[0]?.thread_id?.trim() ?? ""
        } catch (error) {
          console.error(error)
        }
      } else {
        normalizedThreadId = fallbackThreadId
      }

      if (normalizedThreadId) {
        await handleSelectConversation(normalizedThreadId)
      } else {
        toast.error("Select a conversation before sending a message.")
        return
      }
    }
    if (isSending) return
    const trimmed = composerValue.trim()
    const readyAttachments = attachments.filter((attachment) => attachment.status === "ready")

    if (!trimmed && readyAttachments.length === 0) {
      toast.info("Type a message or add an attachment to send.")
      return
    }

    // Create optimistic message ID
    const optimisticMessageId = `temp-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`
    const now = new Date().toISOString()
    
    // Create optimistic message
    const optimisticMessage: MessageResult = {
      id: optimisticMessageId,
      thread_id: normalizedThreadId,
      sender_id: viewer.id,
      message_type: "text",
      content: trimmed.length > 0 ? trimmed : null,
      metadata: null,
      has_attachments: readyAttachments.length > 0,
      reply_to_message_id: replyingToMessage?.id ?? null,
      created_at: now,
      updated_at: now,
      is_deleted: false,
      attachments: readyAttachments.map((attachment) => ({
        id: `temp-attachment-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`,
        message_id: optimisticMessageId,
        media_type: attachment.mediaType,
        storage_path: attachment.storagePath ?? "",
        mime_type: attachment.mimeType ?? null,
        file_size: attachment.fileSize ?? null,
        duration_seconds: attachment.durationSeconds ?? null,
        file_name: attachment.fileName ?? null,
        created_at: now,
      })),
      read_receipts: [],
      replied_to_message: replyingToMessage
        ? {
            id: replyingToMessage.id,
            sender_id: replyingToMessage.sender_id,
            content: replyingToMessage.content ?? null,
            has_attachments: replyingToMessage.has_attachments ?? false,
            created_at: replyingToMessage.created_at,
          }
        : null,
    }

    // Add optimistic message immediately
    setMessagesByThread((prev) => ({
      ...prev,
      [normalizedThreadId]: [...(prev[normalizedThreadId] ?? []), optimisticMessage],
    }))
    
    const hasImage = optimisticMessage.attachments?.some(a => a.media_type === "image") ?? false
    setConversations((prev) =>
      prev
        .map((item) =>
          item.thread_id === normalizedThreadId
            ? {
                ...item,
                last_message_at: now,
                last_message_preview: optimisticMessage.content ?? (hasImage ? "[image]" : (optimisticMessage.attachments?.length ? "[attachment]" : "")),
                last_message_sender_id: viewer.id,
                updated_at: now,
              }
            : item,
        )
        .sort((a, b) => {
          const aTime = new Date(a.last_message_at ?? a.updated_at).getTime()
          const bTime = new Date(b.last_message_at ?? b.updated_at).getTime()
          return bTime - aTime
        }),
    )

    // Ensure attachment URLs for optimistic message
    ensureAttachmentUrls(optimisticMessage.attachments ?? [])
    resetComposer()
    
    // Scroll to bottom immediately
    requestAnimationFrame(() => {
      const container = messageContainerRef.current
      if (container) {
        container.scrollTop = container.scrollHeight
      }
    })

    // Send message in background (don't block UI)
    setIsSending(true)
    try {
      const response = await fetch(`/api/dm/threads/${normalizedThreadId}/messages`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          content: trimmed.length > 0 ? trimmed : null,
          attachments: readyAttachments.map((attachment) => ({
            storagePath: attachment.storagePath,
            mediaType: attachment.mediaType,
            mimeType: attachment.mimeType,
            fileSize: attachment.fileSize,
            durationSeconds: attachment.durationSeconds,
            fileName: attachment.fileName,
          })),
          replyToMessageId: replyingToMessage?.id ?? null,
        }),
      })

      const payload = await response.json().catch(() => null)

      if (!response.ok) {
        const message = typeof payload?.error === "string" ? payload.error : "Failed to send message"
        throw new Error(message)
      }

      const data = payload
      const sentMessage: MessageResult | undefined = data?.message
      if (sentMessage) {
        const withAttachments: MessageResult = {
          ...sentMessage,
          attachments: sentMessage.attachments ?? [],
          read_receipts: [],
          replied_to_message: sentMessage.replied_to_message ?? null,
        }

        // Replace optimistic message with real message
        setMessagesByThread((prev) => {
          const existingMessages = prev[normalizedThreadId] ?? []
          const optimisticIndex = existingMessages.findIndex((msg) => msg.id === optimisticMessageId)
          
          if (optimisticIndex >= 0) {
            // Replace optimistic message with real one
            const updated = [...existingMessages]
            updated[optimisticIndex] = withAttachments
            return {
              ...prev,
              [normalizedThreadId]: updated,
            }
          } else {
            // Optimistic message not found, just add the real one
            return {
              ...prev,
              [normalizedThreadId]: [...existingMessages, withAttachments],
            }
          }
        })
        
        // Update conversation with real message data
        const hasImageReal = withAttachments.attachments?.some(a => a.media_type === "image") ?? false
        setConversations((prev) =>
          prev
            .map((item) =>
              item.thread_id === normalizedThreadId
                ? {
                    ...item,
                    last_message_at: withAttachments.created_at,
                    last_message_preview: withAttachments.content ?? (hasImageReal ? "[image]" : (withAttachments.attachments?.length ? "[attachment]" : "")),
                    last_message_sender_id: viewer.id,
                    updated_at: new Date().toISOString(),
                  }
                : item,
            )
            .sort((a, b) => {
              const aTime = new Date(a.last_message_at ?? a.updated_at).getTime()
              const bTime = new Date(b.last_message_at ?? b.updated_at).getTime()
              return bTime - aTime
            }),
        )

        ensureAttachmentUrls(withAttachments.attachments ?? [])
      }
    } catch (error) {
      console.error(error)
      
      // Remove optimistic message on error and revert conversation preview
      setMessagesByThread((prev) => {
        const existingMessages = prev[normalizedThreadId] ?? []
        const realMessages = existingMessages.filter((msg) => msg.id !== optimisticMessageId)
        const lastRealMessage = realMessages[realMessages.length - 1]
        
        // Update conversation preview with previous message (if exists)
        if (lastRealMessage) {
          const hasImage = lastRealMessage.attachments?.some(a => a.media_type === "image") ?? false
          setConversations((convPrev) =>
            convPrev
              .map((item) =>
                item.thread_id === normalizedThreadId
                  ? {
                      ...item,
                      last_message_at: lastRealMessage.created_at,
                      last_message_preview: lastRealMessage.content ?? (hasImage ? "[image]" : (lastRealMessage.attachments?.length ? "[attachment]" : "")),
                      last_message_sender_id: lastRealMessage.sender_id,
                      updated_at: lastRealMessage.updated_at,
                    }
                  : item,
              )
              .sort((a, b) => {
                const aTime = new Date(a.last_message_at ?? a.updated_at).getTime()
                const bTime = new Date(b.last_message_at ?? b.updated_at).getTime()
                return bTime - aTime
              }),
          )
        }
        
        // Remove optimistic message
        return {
          ...prev,
          [normalizedThreadId]: realMessages,
        }
      })
      
      // Restore composer content
      setComposerValue(trimmed)
      setAttachments(readyAttachments)
      
      const fallback = "Could not send your message. Please try again."
      const message = error instanceof Error ? error.message || fallback : fallback
      toast.error(message)
    } finally {
      setIsSending(false)
      notifyTyping(false)
      // Clear the typing display timeout immediately when message is sent
      if (selectedThreadId && typingDisplayTimeoutRef.current[selectedThreadId]) {
        clearTimeout(typingDisplayTimeoutRef.current[selectedThreadId])
        delete typingDisplayTimeoutRef.current[selectedThreadId]
      }
    }
  }, [
    attachments,
    displayedConversations,
    composerValue,
    ensureAttachmentUrls,
    isSending,
    refreshConversations,
    handleSelectConversation,
    notifyTyping,
    resetComposer,
    selectedThreadId,
    initialThreadId,
    viewer.id,
  ])

  const handleLongPressStart = useCallback((messageId: string, e: React.TouchEvent) => {
    if (!isMobile) return
    
    touchStart.current = {
      x: e.touches[0].clientX,
      y: e.touches[0].clientY
    }
    
    longPressTimer.current = setTimeout(() => {
      setLongPressMenuOpen(messageId)
      // Haptic feedback if available
      if (navigator.vibrate) {
        navigator.vibrate(50)
      }
    }, 500) // 500ms for long press
  }, [isMobile])

  const handleLongPressMove = useCallback((e: React.TouchEvent) => {
    if (!touchStart.current || !longPressTimer.current) return
    
    const deltaX = Math.abs(e.touches[0].clientX - touchStart.current.x)
    const deltaY = Math.abs(e.touches[0].clientY - touchStart.current.y)
    
    // Cancel if moved more than 10px (user is scrolling)
    if (deltaX > 10 || deltaY > 10) {
      clearTimeout(longPressTimer.current)
      longPressTimer.current = null
      touchStart.current = null
    }
  }, [])

  const handleLongPressEnd = useCallback(() => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current)
      longPressTimer.current = null
    }
    touchStart.current = null
  }, [])

  // Swipe to reply handlers (for both sent and received messages on mobile)
  const handleSwipeStart = useCallback((messageId: string, e: React.TouchEvent) => {
    if (!isMobile) return
    // Don't start swipe if long press menu is open
    if (longPressMenuOpen) return
    
    swipeTouchStart.current = {
      x: e.touches[0].clientX,
      y: e.touches[0].clientY,
      messageId
    }
    setSwipingMessageId(messageId)
  }, [isMobile, longPressMenuOpen])

  const handleSwipeMove = useCallback((e: React.TouchEvent) => {
    if (!swipeTouchStart.current || !isMobile) return
    
    const currentX = e.touches[0].clientX
    const currentY = e.touches[0].clientY
    const messageId = swipeTouchStart.current.messageId
    const deltaX = currentX - swipeTouchStart.current.x
    const deltaY = Math.abs(currentY - swipeTouchStart.current.y)
    
    // Only allow horizontal swipe (vertical movement should be minimal)
    if (deltaY > 30) {
      // Cancel swipe if vertical movement is too much (user is scrolling)
      const cancelledMessageId = messageId
      swipeTouchStart.current = null
      setSwipingMessageId(null)
      setSwipeOffset(prev => {
        const next = { ...prev }
        delete next[cancelledMessageId]
        return next
      })
      return
    }
    
    // Only allow swipe right (positive deltaX) to reply
    if (deltaX > 0) {
      const offset = Math.min(deltaX, 120) // Max swipe distance
      setSwipeOffset(prev => ({
        ...prev,
        [messageId]: offset
      }))
    } else if (deltaX < 0 && swipeOffset[messageId]) {
      // Allow swiping back to cancel
      const offset = Math.max(deltaX, 0)
      setSwipeOffset(prev => ({
        ...prev,
        [messageId]: offset
      }))
    }
  }, [isMobile, swipeOffset])

  const handleSwipeEnd = useCallback((messageId: string) => {
    if (!swipeTouchStart.current || swipeTouchStart.current.messageId !== messageId) {
      setSwipingMessageId(null)
      setSwipeOffset(prev => {
        const next = { ...prev }
        delete next[messageId]
        return next
      })
      return
    }
    
    const offset = swipeOffset[messageId] || 0
    
    // If swiped more than 60px, trigger reply
    if (offset > 60) {
      const message = selectedMessages.find(m => m.id === messageId)
      if (message) {
        setReplyingToMessage(message)
        // Haptic feedback
        if (navigator.vibrate) {
          navigator.vibrate(50)
        }
        // Focus composer after a brief delay
        setTimeout(() => {
          const composer = document.querySelector('textarea[placeholder*="message"]') as HTMLTextAreaElement
          composer?.focus()
        }, 100)
      }
    }
    
    // Reset swipe state
    swipeTouchStart.current = null
    setSwipingMessageId(null)
    setSwipeOffset(prev => {
      const next = { ...prev }
      delete next[messageId]
      return next
    })
  }, [swipeOffset, selectedMessages])

  const handleDeleteMessage = useCallback(async (messageId: string) => {
    if (!selectedThreadId) return
    if (deletingMessageId) return

    try {
      setDeletingMessageId(messageId)
      const response = await fetch(`/api/dm/threads/${selectedThreadId}/messages/${messageId}`, {
        method: "DELETE",
      })

      if (!response.ok) {
        throw new Error("Failed to delete message")
      }

      // Remove message from local state
      const wasLastMessage = messagesByThread[selectedThreadId]?.length > 0 &&
        messagesByThread[selectedThreadId][messagesByThread[selectedThreadId].length - 1]?.id === messageId

      setMessagesByThread((prev) => ({
        ...prev,
        [selectedThreadId]: (prev[selectedThreadId] ?? []).filter((m) => m.id !== messageId),
      }))

      // If we deleted the last message, refresh the thread metadata from the database
      // The database trigger should have updated the thread's last_message_preview
      if (wasLastMessage) {
        const { data: threadData } = await supabase
          .from("dm_threads")
          .select("last_message_at, last_message_preview, last_message_sender_id, updated_at")
          .eq("id", selectedThreadId)
          .single()

        if (threadData) {
          setConversations((prev) =>
            prev
              .map((item) =>
                item.thread_id === selectedThreadId
                  ? {
                      ...item,
                      last_message_at: threadData.last_message_at,
                      last_message_preview: threadData.last_message_preview,
                      last_message_sender_id: threadData.last_message_sender_id,
                      updated_at: threadData.updated_at,
                    }
                  : item,
              )
              .sort((a, b) => {
                const aTime = new Date(a.last_message_at ?? a.updated_at).getTime()
                const bTime = new Date(b.last_message_at ?? b.updated_at).getTime()
                return bTime - aTime
              }),
          )
        }
      }

      toast.success("Message deleted")
    } catch (error) {
      console.error(error)
      toast.error("Failed to delete message")
    } finally {
      setDeletingMessageId(null)
    }
  }, [selectedThreadId, deletingMessageId, messagesByThread])

  // Voice note playback is now handled by VoiceNotePlayer component


  const handleLoadOlderMessages = useCallback(async () => {
    const normalizedThreadId = selectedThreadId?.trim()
    if (!normalizedThreadId) return
    const pagination = threadPagination[normalizedThreadId]
    if (!pagination?.hasMore || loadingOlderMessages) return

    try {
      setLoadingOlderMessages(true)
      const params = new URLSearchParams()
      params.set("limit", String(DEFAULT_PAGE_SIZE))
      if (pagination.nextCursor) {
        params.set("before", pagination.nextCursor)
      }

      const response = await fetch(`/api/dm/threads/${normalizedThreadId}/messages?${params.toString()}`, {
        cache: "no-store",
      })
      if (!response.ok) {
        throw new Error("Failed to load older messages")
      }
      const data = await response.json()
      const fetchedMessages: MessageResult[] = data.messages ?? []
      setMessagesByThread((prev) => ({
        ...prev,
        [normalizedThreadId]: [...fetchedMessages, ...(prev[normalizedThreadId] ?? [])],
      }))
      setThreadPagination((prev) => ({
        ...prev,
        [normalizedThreadId]: {
          hasMore: Boolean(data.pageInfo?.hasMore),
          nextCursor: data.pageInfo?.nextCursor ?? null,
        },
      }))
      ensureAttachmentUrls(fetchedMessages.flatMap((m) => m.attachments ?? []))
    } catch (error) {
      console.error(error)
      toast.error("Unable to load more messages.")
    } finally {
      setLoadingOlderMessages(false)
    }
  }, [ensureAttachmentUrls, loadingOlderMessages, selectedThreadId, threadPagination])

  const typingActive = selectedThreadId ? displayTypingIndicators[selectedThreadId] : false
  const peerProfile = selectedConversation?.other_user_profile ?? null

  // Scroll to bottom when typing indicator appears (only if user is near bottom)
  useEffect(() => {
    if (!selectedThreadId || !typingActive) return
    const container = messageContainerRef.current
    if (!container) return
    // Only auto-scroll if user is near the bottom (within 100px)
    const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100
    if (isNearBottom) {
      requestAnimationFrame(() => {
        container.scrollTop = container.scrollHeight
      })
    }
  }, [typingActive, selectedThreadId])

  // Check scroll position to show/hide scroll to bottom button
  useEffect(() => {
    const container = messageContainerRef.current
    if (!container || !selectedThreadId) {
      setShowScrollToBottom(false)
      return
    }

    const checkScrollPosition = () => {
      const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100
      setShowScrollToBottom(!isNearBottom)
    }

    container.addEventListener('scroll', checkScrollPosition)
    // Check after messages load
    setTimeout(checkScrollPosition, 100)

    return () => {
      container.removeEventListener('scroll', checkScrollPosition)
    }
  }, [selectedThreadId])

  // Re-check scroll position when messages change
  useEffect(() => {
    if (!selectedThreadId) return
    const container = messageContainerRef.current
    if (container) {
      const checkScrollPosition = () => {
        const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100
        setShowScrollToBottom(!isNearBottom)
      }
      setTimeout(checkScrollPosition, 100)
    }
  }, [selectedMessages, selectedThreadId])

  const scrollToBottom = useCallback(() => {
    const container = messageContainerRef.current
    if (container) {
      container.scrollTo({
        top: container.scrollHeight,
        behavior: 'smooth'
      })
    }
  }, [])

  const peerName = getDisplayName(peerProfile)
  const peerInitials = getInitials(peerProfile)
  const peerAvatar = peerProfile?.profile_picture ?? null
  const isPeerOnline = selectedThreadId ? presenceMap[selectedThreadId] ?? false : false
  // Only disable composer if participant is blocked
  const composerDisabled = selectedConversation?.participant_status === "blocked"

  const conversationsToRender = displayedConversations

  const handleBackToList = useCallback(() => {
    setMobileView("list")
  }, [])

  return (
    <div className="flex flex-col h-[calc(100dvh-5rem-3rem)] lg:h-[calc(100dvh-5rem)] w-full">
      <div className="flex flex-col lg:flex-row gap-4 h-full overflow-hidden">
        <div className={cn(
          "w-full lg:w-[360px] xl:w-[400px] lg:flex-none flex flex-col h-full",
          !isClient && "lg:flex hidden",
          isClient && isMobile && mobileView === "conversation" && "hidden"
        )}>
          <div className="bg-white/10 border border-white/20 rounded-2xl backdrop-blur-md shadow-[0_20px_60px_-15px_rgba(0,0,0,0.45)] flex flex-col h-full">
            <div className="p-4 border-b border-white/15">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-white/40" />
                <Input
                  value={searchTerm}
                  onChange={(event) => setSearchTerm(event.target.value)}
                  placeholder="Search conversations"
                  className="bg-white/10 border-white/15 text-white pl-9 placeholder:text-white/40"
                />
                {searchLoading && (
                  <Loader2 className="absolute right-3 top-1/2 h-4 w-4 -translate-y-1/2 animate-spin text-white/60" />
                )}
              </div>
            </div>
            <ScrollArea className="flex-1">
              <div className="p-2 space-y-2 min-w-0">
                {conversationsToRender.length === 0 && (
                  <div className="px-3 py-8 text-center text-white/50 text-sm">
                    No conversations found yet. Follow someone and start a chat!
                  </div>
                )}
                {conversationsToRender.map((conversation) => {
                  const otherProfile = conversation.other_user_profile
                  const displayName = getDisplayName(otherProfile)
                  const initials = getInitials(otherProfile)
                  const avatarImage = otherProfile?.profile_picture ?? undefined
                  // Only show selected state on desktop - on mobile, the list is hidden when viewing a conversation
                  const selected = !isMobile && conversation.thread_id === selectedThreadId
                  const lastMessagePreview = liveMessagePreviews[conversation.thread_id]?.content || conversation.last_message_preview || (conversation.last_message_sender_id ? "[attachment]" : "No messages yet")
                  const unread =
                    conversation.last_message_sender_id &&
                    conversation.last_message_sender_id !== viewer.id &&
                    conversation.last_message_at &&
                    (!conversation.last_read_at ||
                      new Date(conversation.last_message_at).getTime() > new Date(conversation.last_read_at).getTime())

                  const typingForConversation =
                    typingIndicators[conversation.thread_id] && typingIndicators[conversation.thread_id]?.userId === conversation.other_user_id

                  return (
                    <button
                      key={conversation.thread_id}
                      type="button"
                      onClick={() => handleSelectConversation(conversation.thread_id)}
                      onMouseEnter={() => {
                        // Prefetch messages on hover for instant switching (desktop only)
                        if (!isMobile) {
                          prefetchMessages(conversation.thread_id)
                        }
                      }}
                      className={cn(
                        "w-full max-w-full box-border rounded-xl border transition-all text-left backdrop-blur-md cursor-pointer overflow-hidden",
                        "bg-white/5 border-white/10 hover:bg-white/10 hover:border-white/20",
                        selected && "bg-white/10 border-white/20 shadow-[0_12px_40px_-12px_rgba(0,0,0,0.6)]",
                      )}
                    >
                      <div className="px-3 py-3 flex items-start gap-3 w-full overflow-hidden">
                        <div onClick={(e) => e.stopPropagation()}>
                          <Avatar 
                            className="h-11 w-11 border-4 border-white/20 flex-shrink-0" 
                            userId={otherProfile?.id} 
                            isOnline={presenceMap[conversation.thread_id] || false}
                            showHoverCard={true}
                            username={otherProfile?.username || undefined}
                            firstName={otherProfile?.first_name || undefined}
                            lastName={otherProfile?.last_name || undefined}
                            profilePicture={otherProfile?.profile_picture || undefined}
                            bio={otherProfile?.bio || undefined}
                          >
                            <AvatarImage src={avatarImage} alt={displayName} />
                            <AvatarFallback className="bg-gradient-to-br from-primary to-primary/70 text-primary-foreground uppercase">
                              {initials}
                            </AvatarFallback>
                          </Avatar>
                        </div>
                        <div className="flex-1 min-w-0 w-0 overflow-hidden">
                          <div className="flex items-center gap-2 min-w-0 overflow-hidden">
                            <p className="text-white/80 font-medium truncate flex-shrink">{displayName}</p>
                            {typingForConversation && (
                              <Badge className="bg-emerald-500/20 border border-emerald-500/30 text-emerald-100 flex-shrink-0">Typing</Badge>
                            )}
                          </div>
                          {typingForConversation ? (
                            <p className={cn("text-xs truncate", unread ? "text-white" : "text-white/50")}>
                              Typing
                            </p>
                          ) : conversationImagePreviews[conversation.thread_id]?.url ? (
                            <div className="flex items-center gap-2">
                              <div className="h-4 w-4 rounded border border-white/20 overflow-hidden flex-shrink-0 bg-white/5">
                                <Image
                                  src={conversationImagePreviews[conversation.thread_id].url}
                                  alt="Image preview"
                                  width={16}
                                  height={16}
                                  className="h-full w-full object-cover"
                                />
                              </div>
                              {lastMessagePreview && lastMessagePreview !== "[image]" && lastMessagePreview !== "[attachment]" && (
                                <p className={cn("text-xs truncate", unread ? "text-white" : "text-white/50")}>
                                  {lastMessagePreview}
                                </p>
                              )}
                            </div>
                          ) : (
                            <p
                              className={cn("text-xs truncate", unread ? "text-white" : "text-white/50")}
                            >
                              {lastMessagePreview}
                            </p>
                          )}
                        </div>
                        <div className="flex flex-col items-end gap-2 flex-shrink-0">
                          <span className="text-[11px] text-white/50 whitespace-nowrap" suppressHydrationWarning>
                            {conversation.last_message_at
                              ? formatRelativeTime(conversation.last_message_at)
                              : formatRelativeTime(conversation.updated_at)}
                          </span>
                          {(() => {
                            const unreadCount = unreadCounts[conversation.thread_id] || 0
                            if (unreadCount > 0) {
                              return (
                                <Badge className="h-5 min-w-5 px-1.5 flex items-center justify-center bg-white/90 text-black border-0 text-[10px] font-semibold shadow-md">
                                  {unreadCount > 99 ? "99+" : unreadCount}
                                </Badge>
                              )
                            }
                            return null
                          })()}
                        </div>
                      </div>
                    </button>
                  )
                })}
              </div>
            </ScrollArea>
          </div>
        </div>

        <div className={cn(
          "flex flex-col h-full overflow-hidden lg:flex-1",
          !isClient && "hidden lg:flex",
          isClient && isMobile && mobileView === "list" && "hidden lg:flex",
          isClient && isMobile && mobileView === "conversation" && "flex"
        )}>
          <div className="bg-white/10 border border-white/20 rounded-2xl backdrop-blur-md shadow-[0_20px_60px_-15px_rgba(0,0,0,0.45)] flex flex-col h-full">
            {selectedConversation ? (
              <>
                <div className="p-4 border-b border-white/15 flex items-center justify-between gap-3">
                  <div className="flex items-center gap-3 min-w-0 flex-1">
                    {isMobile && (
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={handleBackToList}
                        className="rounded-full text-white/70 hover:text-white/90 hover:bg-white/10 shrink-0"
                      >
                        <ArrowLeft className="h-5 w-5" />
                      </Button>
                    )}
                    <div onClick={(e) => e.stopPropagation()}>
                      <Avatar 
                        className="h-11 w-11 border-4 border-white/20" 
                        userId={peerProfile?.id} 
                        isOnline={isPeerOnline}
                        showHoverCard={true}
                        username={peerProfile?.username || undefined}
                        firstName={peerProfile?.first_name || undefined}
                        lastName={peerProfile?.last_name || undefined}
                        profilePicture={peerProfile?.profile_picture || undefined}
                        bio={peerProfile?.bio || undefined}
                      >
                        <AvatarImage src={peerAvatar ?? undefined} alt={peerName} />
                        <AvatarFallback className="bg-gradient-to-br from-primary to-primary/70 text-primary-foreground uppercase">
                          {peerInitials}
                        </AvatarFallback>
                      </Avatar>
                    </div>
                    <div className="min-w-0">
                      <div className="flex items-center gap-2">
                        <h2 className="text-white/90 font-semibold text-sm sm:text-base truncate">{peerName}</h2>
                      </div>
                      <p className="text-xs text-white/50" suppressHydrationWarning>
                        {isPeerOnline ? "Online now" : `Last active ${formatRelativeTime(selectedConversation.other_last_seen_at ?? selectedConversation.updated_at)}`}
                      </p>
                    </div>
                  </div>
                </div>
                <div className="flex-1 flex flex-col overflow-hidden relative">
                  <div ref={messageContainerRef} className="flex-1 overflow-y-auto overflow-x-hidden">
                    {loadingThreadId === selectedThreadId && selectedMessages.length === 0 ? (
                      // Show loading state while fetching messages for the first time
                      <div className="flex-1 flex items-center justify-center min-h-[200px]">
                        <div className="flex flex-col items-center gap-3">
                          <Loader2 className="h-6 w-6 animate-spin text-white/60" />
                          <p className="text-white/50 text-sm">Loading messages...</p>
                        </div>
                      </div>
                    ) : (
                      <div className="px-2 sm:px-4 py-3 sm:py-4 space-y-2">
                        {threadPagination[selectedConversation.thread_id]?.hasMore && (
                          <div className="flex justify-center">
                            <Button
                              variant="ghost"
                              size="sm"
                              className="text-white/70 hover:text-white/90 hover:bg-white/10 border border-white/20"
                              onClick={handleLoadOlderMessages}
                              disabled={loadingOlderMessages}
                            >
                              {loadingOlderMessages ? (
                                <>
                                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                                  Loading
                                </>
                              ) : (
                                "Load previous messages"
                              )}
                            </Button>
                          </div>
                        )}

                        {selectedMessages.map((message) => {
                        const isOwn = message.sender_id === viewer.id
                        const attachmentsForMessage = message.attachments ?? []
                        const hasImages = attachmentsForMessage.some(a => a.media_type === "image")
                        const hasVideos = attachmentsForMessage.some(a => a.media_type === "video")
                        const hasAudio = attachmentsForMessage.some(a => a.media_type === "audio")
                        const isImageOnly = hasImages && !message.content
                        const isVideoOnly = hasVideos && !message.content && !hasImages
                        const isAudioOnly = hasAudio && !message.content && !hasImages && !hasVideos
                        const isDeleting = deletingMessageId === message.id
                        
                        return (
                          <div 
                            key={message.id} 
                            ref={(el) => {
                              if (el) {
                                messageRefs.current.set(message.id, el)
                              } else {
                                messageRefs.current.delete(message.id)
                              }
                            }}
                            className={cn("flex gap-1.5 sm:gap-2 group relative items-center", isOwn ? "justify-end" : "justify-start")}
                          >
                            <div
                              className={cn(
                                "rounded-2xl backdrop-blur-sm relative transition-all duration-500 z-10",
                                highlightedMessageId === message.id && "ring-4 ring-white/70 shadow-2xl shadow-white/30 z-10",
                                isAudioOnly 
                                  ? "w-[280px] sm:w-[320px]"
                                  : "max-w-[85%] sm:max-w-[70%] lg:max-w-[65%]",
                                isImageOnly || isVideoOnly || isAudioOnly ? "p-0" : "px-2.5 sm:px-3 py-2 sm:py-2.5",
                                isOwn
                                  ? "bg-gradient-to-br from-black/40 to-black/60 text-white"
                                  : "bg-gradient-to-br from-white/15 to-white/8 text-white",
                                isDeleting && "opacity-50",
                                isMobile && isOwn && !isDeleting && "select-none"
                              )}
                              style={{
                                transform: swipeOffset[message.id] !== undefined && swipeOffset[message.id] > 0 ? `translate3d(${swipeOffset[message.id]}px, 0, 0)` : undefined,
                                transition: swipingMessageId === message.id ? 'none' : 'transform 0.15s cubic-bezier(0.4, 0, 0.2, 1)',
                                willChange: swipingMessageId === message.id ? 'transform' : 'auto'
                              }}
                              onTouchStart={(e) => {
                                if (!isDeleting && isMobile) {
                                  // Start both long press and swipe detection
                                  handleLongPressStart(message.id, e)
                                  handleSwipeStart(message.id, e)
                                }
                              }}
                              onTouchMove={(e) => {
                                if (!isDeleting && isMobile) {
                                  handleLongPressMove(e)
                                  handleSwipeMove(e)
                                }
                              }}
                              onTouchEnd={(e) => {
                                if (!isDeleting && isMobile) {
                                  handleLongPressEnd()
                                  handleSwipeEnd(message.id)
                                }
                              }}
                              onTouchCancel={(e) => {
                                if (!isDeleting && isMobile) {
                                  handleLongPressEnd()
                                  handleSwipeEnd(message.id)
                                }
                              }}
                            >
                              {/* Swipe to reply indicator (only on mobile, for both sent and received messages) */}
                              {isMobile && !isDeleting && swipeOffset[message.id] !== undefined && swipeOffset[message.id] > 0 && (
                                <div 
                                  className={cn(
                                    "absolute top-1/2 flex items-center justify-center w-9 h-9 rounded-full bg-white/10 backdrop-blur-sm border border-white/20 z-20",
                                    isOwn ? "-left-12" : "-right-12"
                                  )}
                                  style={{
                                    opacity: Math.min(swipeOffset[message.id] / 60, 1),
                                    transform: 'translateY(-50%)',
                                    willChange: 'opacity',
                                    transition: 'opacity 0.1s ease-out'
                                  }}
                                >
                                  <Reply className="h-4 w-4 text-white/80" />
                                </div>
                              )}
                              {isOwn && !isDeleting && (
                                <DropdownMenu open={isMobile ? longPressMenuOpen === message.id : undefined} onOpenChange={(open) => {
                                  if (isMobile && !open) {
                                    setLongPressMenuOpen(null)
                                  }
                                }}>
                                  <DropdownMenuTrigger asChild>
                                    <button
                                      type="button"
                                      className="absolute top-0 right-0 opacity-0 group-hover:opacity-100 transition-opacity text-white/70 hover:text-white/90 focus:outline-none focus-visible:outline-none active:outline-none cursor-pointer p-2 z-40 rounded-full"
                                      style={{
                                        background: 'radial-gradient(circle, rgba(0,0,0,0.2) 0%, rgba(0,0,0,0.15) 30%, rgba(0,0,0,0.08) 50%, rgba(0,0,0,0.03) 70%, transparent 100%)'
                                      }}
                                      onClick={(e) => {
                                        e.stopPropagation()
                                      }}
                                      onTouchStart={(e) => {
                                        e.stopPropagation()
                                      }}
                                    >
                                      <ChevronDown className="h-5 w-5" />
                                    </button>
                                  </DropdownMenuTrigger>
                                  <DropdownMenuContent
                                    align="end"
                                    side="bottom"
                                    sideOffset={8}
                                    className="bg-white/10 border border-white/20 backdrop-blur-xl"
                                    onClick={(e) => e.stopPropagation()}
                                  >
                                    <DropdownMenuItem
                                      onClick={(e) => {
                                        e.stopPropagation()
                                        setReplyingToMessage(message)
                                        // Focus composer after a brief delay to ensure it's rendered
                                        setTimeout(() => {
                                          const composer = document.querySelector('textarea[placeholder*="message"]') as HTMLTextAreaElement
                                          composer?.focus()
                                        }, 100)
                                      }}
                                      className="text-white/80 hover:text-white hover:bg-white/10 cursor-pointer focus:text-white focus:bg-white/10"
                                    >
                                      <Reply className="h-3.5 w-3.5 mr-2" />
                                      Reply
                                    </DropdownMenuItem>
                                    <DropdownMenuItem
                                      onClick={(e) => {
                                        e.stopPropagation()
                                        handleDeleteMessage(message.id)
                                      }}
                                      className="text-red-400 hover:text-red-300 hover:bg-red-500/20 cursor-pointer focus:text-red-300 focus:bg-red-500/20"
                                    >
                                      <Trash2 className="h-3.5 w-3.5 mr-2" />
                                      Delete message
                                    </DropdownMenuItem>
                                  </DropdownMenuContent>
                                </DropdownMenu>
                              )}
                              {!isOwn && !isDeleting && (
                                <DropdownMenu open={isMobile ? longPressMenuOpen === message.id : undefined} onOpenChange={(open) => {
                                  if (isMobile && !open) {
                                    setLongPressMenuOpen(null)
                                  }
                                }}>
                                  <DropdownMenuTrigger asChild>
                                    <button
                                      type="button"
                                      className="absolute top-0 right-0 opacity-0 group-hover:opacity-100 transition-opacity text-white/70 hover:text-white/90 focus:outline-none focus-visible:outline-none active:outline-none cursor-pointer p-2 z-40 rounded-full"
                                      style={{
                                        background: 'radial-gradient(circle, rgba(0,0,0,0.2) 0%, rgba(0,0,0,0.15) 30%, rgba(0,0,0,0.08) 50%, rgba(0,0,0,0.03) 70%, transparent 100%)'
                                      }}
                                      onClick={(e) => {
                                        e.stopPropagation()
                                      }}
                                      onTouchStart={(e) => {
                                        e.stopPropagation()
                                      }}
                                    >
                                      <ChevronDown className="h-5 w-5" />
                                    </button>
                                  </DropdownMenuTrigger>
                                  <DropdownMenuContent
                                    align="end"
                                    side="bottom"
                                    sideOffset={8}
                                    className="bg-white/10 border border-white/20 backdrop-blur-xl"
                                    onClick={(e) => e.stopPropagation()}
                                  >
                                    <DropdownMenuItem
                                      onClick={(e) => {
                                        e.stopPropagation()
                                        setReplyingToMessage(message)
                                        // Focus composer after a brief delay to ensure it's rendered
                                        setTimeout(() => {
                                          const composer = document.querySelector('textarea[placeholder*="message"]') as HTMLTextAreaElement
                                          composer?.focus()
                                        }, 100)
                                      }}
                                      className="text-white/80 hover:text-white hover:bg-white/10 cursor-pointer focus:text-white focus:bg-white/10"
                                    >
                                      <Reply className="h-3.5 w-3.5 mr-2" />
                                      Reply
                                    </DropdownMenuItem>
                                  </DropdownMenuContent>
                                </DropdownMenu>
                              )}
                              {message.replied_to_message?.id && (() => {
                                // Use attachments from replied_to_message if available, otherwise try to find in thread messages
                                const repliedMessageAttachments = message.replied_to_message.attachments ?? 
                                  (selectedThreadId ? (messagesByThread[selectedThreadId] ?? []) : [])
                                    .find(m => m.id === message.replied_to_message?.id)
                                    ?.attachments ?? []
                                const imageAttachments = repliedMessageAttachments.filter(a => a.media_type === "image")
                                const videoAttachments = repliedMessageAttachments.filter(a => a.media_type === "video")
                                const documentAttachments = repliedMessageAttachments.filter(a => a.media_type === "file")
                                const firstImage = imageAttachments[0]
                                const firstVideo = videoAttachments[0]
                                const firstDocument = documentAttachments[0]
                                const hasImageOrVideo = firstImage || firstVideo
                                const hasDocument = firstDocument && !hasImageOrVideo
                                
                                return (
                                  <div 
                                    className={cn(
                                      "mb-1.5 w-full py-1.5 px-2 rounded-lg border-l-2 flex items-start gap-2 cursor-pointer hover:opacity-80 transition-opacity",
                                      isOwn 
                                        ? "bg-black/20 border-white/30" 
                                        : "bg-white/5 border-white/20"
                                    )}
                                    onClick={(e) => {
                                      e.stopPropagation()
                                      if (message.replied_to_message?.id) {
                                        scrollToMessage(message.replied_to_message.id)
                                      }
                                    }}
                                  >
                                    {(hasImageOrVideo || hasDocument) && (
                                      <div className="h-8 w-8 sm:h-10 sm:w-10 rounded-lg overflow-hidden border border-white/20 bg-black/20 flex-shrink-0 relative">
                                        {firstImage && attachmentUrls[firstImage.id]?.url ? (
                                          <Image
                                            src={attachmentUrls[firstImage.id].url}
                                            alt="Shared image"
                                            width={40}
                                            height={40}
                                            className="h-full w-full object-cover"
                                          />
                                        ) : firstVideo && attachmentUrls[firstVideo.id]?.url ? (
                                          <>
                                            <video
                                              src={attachmentUrls[firstVideo.id].url}
                                              className="h-full w-full object-cover"
                                              muted
                                              playsInline
                                            />
                                            <div className="absolute inset-0 flex items-center justify-center bg-black/30">
                                              <Video className="h-3 w-3 sm:h-4 sm:w-4 text-white/80" />
                                            </div>
                                          </>
                                        ) : (
                                          <div className="h-full w-full flex items-center justify-center bg-white/5">
                                            {firstImage ? (
                                              <ImageIcon className="h-3.5 w-3.5 sm:h-4 sm:w-4 text-white/50" />
                                            ) : firstVideo ? (
                                              <Video className="h-3.5 w-3.5 sm:h-4 sm:w-4 text-white/50" />
                                            ) : (
                                              <FileText className="h-3.5 w-3.5 sm:h-4 sm:w-4 text-white/50" />
                                            )}
                                          </div>
                                        )}
                                      </div>
                                    )}
                                    <div className="flex-1 min-w-0">
                                      <div className="flex items-center gap-1.5 mb-0.5">
                                        <Reply className="h-3 w-3 text-white/50 flex-shrink-0" />
                                        <span className="text-[10px] text-white/60 font-medium">
                                          {message.replied_to_message.sender_id === viewer.id ? "You" : peerName}
                                        </span>
                                      </div>
                                      {message.replied_to_message.content ? (
                                        <p className="text-[10px] text-white/50 line-clamp-2 truncate">
                                          {message.replied_to_message.content}
                                        </p>
                                      ) : message.replied_to_message.has_attachments ? (
                                        <p className="text-[10px] text-white/50 italic">
                                          {firstImage ? "[image]" : firstVideo ? "[video]" : firstDocument ? (firstDocument.file_name || "[document]") : "[attachment]"}
                                        </p>
                                      ) : (
                                        <p className="text-[10px] text-white/50 italic">[message]</p>
                                      )}
                                    </div>
                                  </div>
                                )
                              })()}
                             <div className={cn(isImageOnly || isVideoOnly ? "" : "space-y-1.5", !hasImages && !hasVideos && !isAudioOnly && "pr-12 sm:pr-14")}>
                                {attachmentsForMessage.length > 0 && (
                                  <div className={cn(isImageOnly || isVideoOnly ? "" : "space-y-2", message.content && "mb-1.5")}>
                                  {attachmentsForMessage.map((attachment, attachmentIndex) => {
                                    const signedUrl = attachmentUrls[attachment.id]?.url
                                    if (attachment.media_type === "image") {
                                      // Get all image attachments for this message for lightbox navigation
                                      const imageAttachments = attachmentsForMessage.filter(a => a.media_type === "image")
                                      const imageIndex = imageAttachments.findIndex(a => a.id === attachment.id)
                                      
                                      const handleImageClick = () => {
                                        // Build array of image URLs for lightbox
                                        const images = imageAttachments.map(img => ({
                                          id: img.id,
                                          url: attachmentUrls[img.id]?.url || ""
                                        })).filter(img => img.url) // Only include images with URLs
                                        
                                        if (images.length > 0) {
                                          setLightboxImages(images)
                                          setLightboxIndex(imageIndex >= 0 ? imageIndex : 0)
                                          setLightboxOpen(true)
                                        }
                                      }
                                      
                                      return (
                                        <div 
                                          key={`${message.id}-${attachment.id}-${attachmentIndex}`} 
                                          className={cn(
                                            "overflow-hidden border border-white/20 bg-black/20 relative flex-shrink-0 cursor-pointer hover:opacity-90 transition-opacity",
                                            isImageOnly ? "rounded-2xl" : "rounded-lg"
                                          )}
                                          onClick={handleImageClick}
                                        >
                                          {signedUrl ? (
                                            <Image
                                              src={signedUrl}
                                              alt="Shared image"
                                              width={640}
                                              height={640}
                                              className="w-full h-auto object-cover max-h-[200px] sm:max-h-[280px] block pointer-events-none"
                                              style={{ maxHeight: '280px' }}
                                            />
                                          ) : (
                                            <div className="h-32 flex items-center justify-center text-white/50 text-xs bg-white/5">
                                              Loading image
                                            </div>
                                          )}
                                        </div>
                                      )
                                    }
                                    if (attachment.media_type === "audio") {
                                      const signedUrl = attachmentUrls[attachment.id]?.url
                                      if (!signedUrl) return null
                                      
                                      const senderProfile = isOwn ? viewer : peerProfile
                                      const senderAvatar = isOwn ? viewer.profile_picture : peerAvatar
                                      const senderInitials = isOwn ? getInitials(viewer) : peerInitials
                                      const senderName = isOwn ? getDisplayName(viewer) : peerName
                                      const senderId = isOwn ? viewer.id : peerProfile?.id
                                      
                                      return (
                                        <VoiceNotePlayer
                                          key={`${message.id}-${attachment.id}-${attachmentIndex}`}
                                          audioUrl={signedUrl}
                                          attachmentId={attachment.id}
                                          senderId={senderId}
                                          senderAvatar={senderAvatar}
                                          senderInitials={senderInitials}
                                          senderName={senderName}
                                          isPlaying={playingAudio === attachment.id}
                                          onPlayStateChange={(attachmentId, isPlaying) => {
                                            setPlayingAudio(isPlaying ? attachmentId : null)
                                          }}
                                          onStopOthers={(currentId) => {
                                            // Stop other audio (from other voice note players)
                                            if (playingAudio && playingAudio !== currentId) {
                                              setPlayingAudio(null)
                                            }
                                          }}
                                        />
                                      )
                                    }
                                    if (attachment.media_type === "video") {
                                      const signedUrl = attachmentUrls[attachment.id]?.url
                                      const isPlaying = playingVideo === attachment.id
                                      
                                      const handlePlayClick = async (e: React.MouseEvent) => {
                                        e.stopPropagation()
                                        const video = videoRefs.current[attachment.id]
                                        if (!video) return
                                        
                                        try {
                                          await video.play()
                                          setPlayingVideo(attachment.id)
                                        } catch (error) {
                                          console.error('Error playing video:', error)
                                        }
                                      }
                                      
                                      return (
                                        <div
                                          key={`${message.id}-${attachment.id}-${attachmentIndex}`}
                                          className={cn(
                                            "overflow-hidden border border-white/20 bg-black/20 relative flex-shrink-0 rounded-lg",
                                            !isPlaying && "cursor-pointer",
                                            isImageOnly || isVideoOnly ? "rounded-2xl" : "rounded-lg"
                                          )}
                                          onClick={!isPlaying ? handlePlayClick : undefined}
                                        >
                                          {signedUrl ? (
                                            <div className="relative">
                                              <video
                                                ref={(el) => {
                                                  if (el && !videoRefs.current[attachment.id]) {
                                                    videoRefs.current[attachment.id] = el
                                                    // Set up event listeners once
                                                    const handlePlay = () => setPlayingVideo(attachment.id)
                                                    const handlePause = () => {
                                                      if (el.paused) {
                                                        setPlayingVideo(null)
                                                      }
                                                    }
                                                    const handleEnded = () => setPlayingVideo(null)
                                                    
                                                    el.addEventListener('play', handlePlay)
                                                    el.addEventListener('pause', handlePause)
                                                    el.addEventListener('ended', handleEnded)
                                                    
                                                    // Store cleanup function on the element
                                                    ;(el as any)._cleanup = () => {
                                                      el.removeEventListener('play', handlePlay)
                                                      el.removeEventListener('pause', handlePause)
                                                      el.removeEventListener('ended', handleEnded)
                                                    }
                                                  }
                                                }}
                                                src={signedUrl}
                                                className="w-full h-auto object-cover max-h-[200px] sm:max-h-[280px] block rounded-lg"
                                                style={{ maxHeight: '280px' }}
                                                controls={isPlaying}
                                                controlsList="nodownload"
                                                playsInline
                                                preload="metadata"
                                                onClick={(e) => {
                                                  if (isPlaying) {
                                                    e.stopPropagation()
                                                  }
                                                }}
                                              />
                                              {!isPlaying && (
                                                <div 
                                                  className="absolute inset-0 flex items-center justify-center bg-black/30 pointer-events-none z-10 rounded-lg"
                                                >
                                                  <div className="bg-black/60 rounded-full p-3 backdrop-blur-sm">
                                                    <Play className="h-8 w-8 text-white/90 fill-white/90" />
                                                  </div>
                                                </div>
                                              )}
                                            </div>
                                          ) : (
                                            <div className="h-32 flex items-center justify-center text-white/50 text-xs bg-white/5">
                                              <Video className="h-8 w-8 text-white/50" />
                                            </div>
                                          )}
                                        </div>
                                      )
                                    }
                                    if (attachment.media_type === "file") {
                                      const signedUrl = attachmentUrls[attachment.id]?.url
                                      // Use file_name from database (original file name), fallback to storage path for old records
                                      const fileName = attachment.file_name ?? attachment.storage_path?.split('/').pop() ?? 'file'
                                      
                                      const handleDownload = async () => {
                                        if (downloadingAttachmentId === attachment.id) return // Prevent double clicks
                                        
                                        try {
                                          setDownloadingAttachmentId(attachment.id)
                                          
                                          // Use API route to download (hides Supabase URL and ensures proper download)
                                          const response = await fetch(`/api/dm/download/${attachment.id}`)
                                          
                                          if (!response.ok) {
                                            throw new Error("Download failed")
                                          }
                                          
                                          // Get file blob
                                          const blob = await response.blob()
                                          
                                          // Create download link
                                          const url = window.URL.createObjectURL(blob)
                                          const link = document.createElement('a')
                                          link.href = url
                                          link.download = fileName
                                          link.style.display = 'none'
                                          document.body.appendChild(link)
                                          link.click()
                                          
                                          // Cleanup
                                          document.body.removeChild(link)
                                          window.URL.revokeObjectURL(url)
                                        } catch (error) {
                                          console.error("Download error:", error)
                                          toast.error("Failed to download file")
                                        } finally {
                                          setDownloadingAttachmentId(null)
                                        }
                                      }
                                      
                                      return (
                                        <div
                                          key={`${message.id}-${attachment.id}-${attachmentIndex}`}
                                          className="bg-white/5 border border-white/15 rounded-lg px-3 py-2 text-white/75 text-xs"
                                        >
                                          <div className="flex items-center gap-2">
                                            <FileText className="h-4 w-4 text-white/70 flex-shrink-0" />
                                            <span className="flex-1 truncate min-w-0" title={fileName}>
                                              {fileName}
                                            </span>
                                            <button
                                              type="button"
                                              onClick={(e) => {
                                                e.stopPropagation()
                                                handleDownload()
                                              }}
                                              disabled={downloadingAttachmentId === attachment.id}
                                              className="flex-shrink-0 p-1 rounded hover:bg-white/10 text-white/70 hover:text-white/90 transition disabled:opacity-50 disabled:cursor-not-allowed cursor-pointer"
                                              title={downloadingAttachmentId === attachment.id ? "Downloading..." : "Download file"}
                                            >
                                              {downloadingAttachmentId === attachment.id ? (
                                                <Loader2 className="h-3.5 w-3.5 animate-spin" />
                                              ) : (
                                                <Download className="h-3.5 w-3.5" />
                                              )}
                                            </button>
                                          </div>
                                        </div>
                                      )
                                    }
                                    return (
                                      <div
                                        key={`${message.id}-${attachment.id}-${attachmentIndex}`}
                                        className="bg-white/5 border border-white/15 rounded-lg px-3 py-2 text-white/75 text-xs"
                                      >
                                        <div className="flex items-center gap-1.5">
                                          <ImageIcon className="h-3.5 w-3.5 text-white/60" />
                                          <span>Attachment</span>
                                        </div>
                                      </div>
                                    )
                                    })}
                                  </div>
                                )}
                                {message.content && (
                                  <p className={cn(
                                    "text-xs sm:text-sm leading-relaxed whitespace-pre-wrap break-words pr-12 sm:pr-14"
                                  )}>{linkifyText(message.content)}</p>
                                )}
                              </div>
                              {(() => {
                                // Check if any video in this message is playing
                                const hasPlayingVideo = attachmentsForMessage.some(
                                  a => a.media_type === "video" && playingVideo === a.id
                                )
                                // Hide timestamp if a video is playing
                                if (hasPlayingVideo) return null
                                
                                // Check read receipt status for sent messages
                                const readReceipts = message.read_receipts ?? []
                                const otherUserId = selectedConversation?.other_user_id
                                const isRead = isOwn && otherUserId 
                                  ? readReceipts.some((r) => r.user_id === otherUserId)
                                  : false
                                
                                // Determine message status for dots
                                const isSending = isOwn && message.id.startsWith('temp-')
                                const isReadState = isOwn && isRead
                                // For non-temp messages that aren't read, show as "delivered" (gold/purple)
                                // This indicates the message was delivered but not yet read
                                const isDelivered = isOwn && !isSending && !isReadState
                                
                                return (
                                  <div className={cn(
                                    "absolute flex items-center gap-1 text-[9px] sm:text-[10px] font-medium px-1.5 py-0.5 rounded",
                                    isImageOnly || isVideoOnly
                                      ? "bottom-1.5 right-1.5 bg-black/60 text-white/90 backdrop-blur-sm"
                                      : isAudioOnly
                                      ? "bottom-2 right-2 sm:bottom-2.5 sm:right-2.5 text-white/40 px-1"
                                      : "bottom-1.5 right-1.5 text-white/40 px-1"
                                  )}>
                                    {formatTimestamp(message.created_at)}
                                    {isOwn && (
                                      <span className="flex-shrink-0 ml-1">
                                        {isSending ? (
                                          // Sending: White dot with glow
                                          <span 
                                            className="inline-block h-2 w-2 rounded-full bg-white border border-white/50 animate-pulse"
                                            style={{
                                              boxShadow: '0 0 6px rgba(255, 255, 255, 0.6), 0 0 12px rgba(255, 255, 255, 0.3)',
                                            }}
                                          />
                                        ) : isReadState ? (
                                          // Read: Green/blue gradient dot
                                          <span 
                                            className="inline-block h-2 w-2 rounded-full"
                                            style={{
                                              background: 'linear-gradient(135deg, #10B981 0%, #3B82F6 50%, #06B6D4 100%)',
                                              border: '1px solid rgba(16, 185, 129, 0.6)',
                                              boxShadow: '0 0 6px rgba(16, 185, 129, 0.5), 0 0 12px rgba(59, 130, 246, 0.3)',
                                            }}
                                          />
                                        ) : isDelivered ? (
                                          // Delivered (not read): Gold/purple gradient dot
                                          <span 
                                            className="inline-block h-2 w-2 rounded-full"
                                            style={{
                                              background: 'linear-gradient(135deg, #FFD700 0%, #FFA500 50%, #9333EA 100%)',
                                              border: '1px solid rgba(255, 215, 0, 0.6)',
                                              boxShadow: '0 0 6px rgba(255, 215, 0, 0.5), 0 0 12px rgba(147, 51, 234, 0.3)',
                                            }}
                                          />
                                        ) : (
                                          // Fallback: White dot
                                          <span 
                                            className="inline-block h-2 w-2 rounded-full bg-white/40 border border-white/20"
                                          />
                                        )}
                                      </span>
                                    )}
                                  </div>
                                )
                              })()}
                            </div>
                          </div>
                        )
                      })}
                      
                      <MessageImageLightbox
                        images={lightboxImages}
                        initialIndex={lightboxIndex}
                        open={lightboxOpen}
                        onOpenChange={setLightboxOpen}
                      />
                      
                      {typingActive && (
                        <div className="flex gap-1.5 sm:gap-2 justify-start">
                          <div className="rounded-2xl bg-white/10 text-white/85 backdrop-blur-sm px-3 sm:px-4 py-2 sm:py-2.5 flex items-center gap-1">
                            <style dangerouslySetInnerHTML={{
                              __html: `
                                @keyframes typing-dot-bounce {
                                  0%, 60%, 100% {
                                    transform: translateY(0);
                                    opacity: 0.7;
                                  }
                                  30% {
                                    transform: translateY(-8px);
                                    opacity: 1;
                                  }
                                }
                              `
                            }} />
                            <span
                              className="inline-block w-2 h-2 rounded-full bg-white/60"
                              style={{
                                animation: 'typing-dot-bounce 1.4s infinite ease-in-out',
                                animationDelay: '0s'
                              }}
                            />
                            <span
                              className="inline-block w-2 h-2 rounded-full bg-white/60"
                              style={{
                                animation: 'typing-dot-bounce 1.4s infinite ease-in-out',
                                animationDelay: '0.2s'
                              }}
                            />
                            <span
                              className="inline-block w-2 h-2 rounded-full bg-white/60"
                              style={{
                                animation: 'typing-dot-bounce 1.4s infinite ease-in-out',
                                animationDelay: '0.4s'
                              }}
                            />
                          </div>
                        </div>
                      )}
                      </div>
                    )}
                  </div>
                  {showScrollToBottom && (
                    <Button
                      type="button"
                      onClick={scrollToBottom}
                      className="absolute bottom-24 right-4 h-10 w-10 rounded-full border border-white/20 bg-white/10 backdrop-blur-md text-white/70 hover:bg-white/15 hover:text-white/90 hover:border-white/30 flex items-center justify-center shadow-lg z-10"
                      title="Scroll to bottom"
                    >
                      <ChevronDown className="h-5 w-5" />
                    </Button>
                  )}
                  <Separator className="bg-white/10" />
                  <div className="p-2 sm:p-3 space-y-2">
                    {selectedConversation.participant_status === "blocked" && (
                      <div className="bg-white/5 border border-white/20 rounded-xl px-4 py-3 text-white/70 text-sm">
                        <div>
                          You cannot send messages in this conversation.
                        </div>
                      </div>
                    )}
                    {(() => {
                      const shouldRender = attachments.length > 0
                      console.log('[Render] Attachments section check:', {
                        attachmentsLength: attachments.length,
                        shouldRender,
                        attachments: attachments.map(a => ({ 
                          id: a.id, 
                          fileName: a.fileName, 
                          mediaType: a.mediaType, 
                          status: a.status, 
                          hasPreview: !!a.previewUrl 
                        })),
                        selectedThreadId,
                        composerDisabled
                      })
                      return shouldRender
                    })() && (
                      <div className="flex flex-wrap gap-2">
                        {attachments.map((attachment, index) => {
                          console.log('[Render] Rendering attachment item:', {
                            index,
                            id: attachment.id,
                            fileName: attachment.fileName,
                            mediaType: attachment.mediaType,
                            status: attachment.status,
                            hasPreviewUrl: !!attachment.previewUrl
                          })
                          return (
                          <div
                            key={`upload-${attachment.id}-${index}`}
                            className={cn(
                              "relative rounded-xl border px-2.5 sm:px-3 py-1.5 sm:py-2 flex items-center gap-2 text-xs",
                              attachment.status === "error"
                                ? "border-rose-400 text-rose-200 bg-rose-500/15"
                                : "border-white/20 text-white/75 bg-white/10",
                            )}
                          >
                            {attachment.mediaType === "image" && attachment.previewUrl ? (
                              <div className="h-8 w-8 sm:h-10 sm:w-10 rounded-lg overflow-hidden border border-white/20 bg-black/20 flex-shrink-0">
                                <Image
                                  src={attachment.previewUrl}
                                  alt={attachment.fileName}
                                  width={48}
                                  height={48}
                                  className="h-full w-full object-cover"
                                />
                              </div>
                            ) : attachment.mediaType === "video" && attachment.previewUrl ? (
                              <div className="h-8 w-8 sm:h-10 sm:w-10 rounded-lg overflow-hidden border border-white/20 bg-black/20 flex-shrink-0 relative">
                                <video
                                  src={attachment.previewUrl}
                                  className="h-full w-full object-cover"
                                  muted
                                  playsInline
                                />
                                <div className="absolute inset-0 flex items-center justify-center bg-black/30">
                                  <Video className="h-4 w-4 text-white/80" />
                                </div>
                              </div>
                            ) : (
                              <div className="h-8 w-8 sm:h-10 sm:w-10 rounded-lg border border-white/20 bg-white/5 flex items-center justify-center flex-shrink-0">
                                {attachment.mediaType === "audio" && (
                                  <Mic className="h-4 w-4 text-white/70" />
                                )}
                                {attachment.mediaType === "video" && (
                                  <Video className="h-4 w-4 text-white/70" />
                                )}
                                {attachment.mediaType === "file" && (
                                  <FileText className="h-4 w-4 text-white/70" />
                                )}
                                {attachment.mediaType === "image" && (
                                  <ImageIcon className="h-4 w-4 text-white/70" />
                                )}
                              </div>
                            )}
                            <div className="flex-1 min-w-0">
                              <div className="max-w-[160px] truncate" title={attachment.fileName}>
                                {attachment.fileName}
                              </div>
                            </div>
                            {attachment.status === "uploading" && <Loader2 className="h-4 w-4 animate-spin text-white/60 flex-shrink-0" />}
                            {attachment.status === "error" && <span className="text-rose-200 text-[10px] flex-shrink-0">Upload failed</span>}
                            {attachment.mediaType === "file" && attachment.status === "ready" && attachment.storagePath && (
                              <button
                                type="button"
                                onClick={async (e) => {
                                  e.stopPropagation()
                                  try {
                                    // For files in composer, we need to get the attachment ID from the message
                                    // For now, download directly from storage if we have the path
                                    if (attachment.previewUrl) {
                                      // Use preview URL (object URL) for local files
                                      const link = document.createElement('a')
                                      link.href = attachment.previewUrl
                                      link.download = attachment.fileName
                                      link.style.display = 'none'
                                      document.body.appendChild(link)
                                      link.click()
                                      document.body.removeChild(link)
                                    } else {
                                      toast.error("File not available for download")
                                    }
                                  } catch (error) {
                                    console.error("Download error:", error)
                                    toast.error("Failed to download file")
                                  }
                                }}
                                className="flex-shrink-0 p-1 rounded hover:bg-white/10 text-white/70 hover:text-white/90 transition"
                                title="Download file"
                              >
                                <Download className="h-3.5 w-3.5" />
                              </button>
                            )}
                            <button
                              type="button"
                              onClick={() => handleRemoveAttachment(attachment.id)}
                              className="ml-1 rounded-full bg-white/10 hover:bg-white/20 p-1 text-white/60 hover:text-white/90 transition flex-shrink-0"
                            >
                              <X className="h-3 w-3" />
                            </button>
                          </div>
                          )
                        })}
                      </div>
                    )}
                    {isVoiceRecorderOpen && (
                      <VoiceNoteRecorder
                        onRecordingComplete={handleVoiceNoteComplete}
                        onCancel={handleVoiceNoteCancel}
                        maxDurationMinutes={5}
                        autoStart={true}
                      />
                    )}
                    {replyingToMessage && (
                      <div className="w-full mb-2">
                        <div 
                          className="py-2.5 sm:py-3 px-3 sm:px-4 bg-white/5 border-l-2 border-white/30 rounded-lg flex items-start gap-2 cursor-pointer hover:opacity-80 transition-opacity"
                          onClick={() => {
                            if (replyingToMessage.id) {
                              scrollToMessage(replyingToMessage.id)
                            }
                          }}
                        >
                          {(() => {
                            const imageAttachments = replyingToMessage.attachments?.filter(a => a.media_type === "image") ?? []
                            const videoAttachments = replyingToMessage.attachments?.filter(a => a.media_type === "video") ?? []
                            const documentAttachments = replyingToMessage.attachments?.filter(a => a.media_type === "file") ?? []
                            const firstImage = imageAttachments[0]
                            const firstVideo = videoAttachments[0]
                            const firstDocument = documentAttachments[0]
                            const hasImageOrVideo = firstImage || firstVideo
                            const hasDocument = firstDocument && !hasImageOrVideo
                            
                            return (
                              <>
                                {(hasImageOrVideo || hasDocument) && (
                                  <div className="h-12 w-12 sm:h-16 sm:w-16 rounded-lg overflow-hidden border border-white/20 bg-black/20 flex-shrink-0 relative">
                                    {firstImage && attachmentUrls[firstImage.id]?.url ? (
                                      <Image
                                        src={attachmentUrls[firstImage.id].url}
                                        alt="Shared image"
                                        width={64}
                                        height={64}
                                        className="h-full w-full object-cover"
                                      />
                                    ) : firstVideo && attachmentUrls[firstVideo.id]?.url ? (
                                      <>
                                        <video
                                          src={attachmentUrls[firstVideo.id].url}
                                          className="h-full w-full object-cover"
                                          muted
                                          playsInline
                                        />
                                        <div className="absolute inset-0 flex items-center justify-center bg-black/30">
                                          <Video className="h-4 w-4 sm:h-5 sm:w-5 text-white/80" />
                                        </div>
                                      </>
                                    ) : (
                                      <div className="h-full w-full flex items-center justify-center bg-white/5">
                                        {firstImage ? (
                                          <ImageIcon className="h-5 w-5 sm:h-6 sm:w-6 text-white/50" />
                                        ) : firstVideo ? (
                                          <Video className="h-5 w-5 sm:h-6 sm:w-6 text-white/50" />
                                        ) : (
                                          <FileText className="h-5 w-5 sm:h-6 sm:w-6 text-white/50" />
                                        )}
                                      </div>
                                    )}
                                  </div>
                                )}
                                <div className="flex-1 min-w-0">
                                  <div className="flex items-center gap-1.5 mb-0.5">
                                    <Reply className="h-3 w-3 text-white/50 flex-shrink-0" />
                                    <span className="text-[10px] text-white/60 font-medium">
                                      Replying to {replyingToMessage.sender_id === viewer.id ? "yourself" : peerName}
                                    </span>
                                  </div>
                                  {replyingToMessage.content ? (
                                    <p className="text-[10px] text-white/50 line-clamp-2 truncate">
                                      {replyingToMessage.content}
                                    </p>
                                  ) : replyingToMessage.has_attachments ? (
                                    <p className="text-[10px] text-white/50 italic">
                                      {firstImage ? "[image]" : firstVideo ? "[video]" : firstDocument ? (firstDocument.file_name || "[document]") : "[attachment]"}
                                    </p>
                                  ) : (
                                    <p className="text-[10px] text-white/50 italic">[message]</p>
                                  )}
                                </div>
                                <Button
                                  type="button"
                                  variant="ghost"
                                  size="icon"
                                  className="h-5 w-5 rounded-full text-white/50 hover:text-white hover:bg-white/10 flex-shrink-0"
                                  onClick={() => setReplyingToMessage(null)}
                                >
                                  <X className="h-3 w-3" />
                                </Button>
                              </>
                            )
                          })()}
                        </div>
                      </div>
                    )}
                    <div
                      className={cn(
                        "flex items-end gap-2 sm:gap-3 bg-white/10 border border-white/20 rounded-2xl px-2 sm:px-3 py-1.5 sm:py-2",
                        composerDisabled && "opacity-60 pointer-events-none",
                      )}
                    >
                      <div className="flex items-center gap-1.5 sm:gap-2 flex-shrink-0">
                        <DropdownMenu open={attachMenuOpen} onOpenChange={setAttachMenuOpen}>
                          <DropdownMenuTrigger asChild>
                            <Button
                              type="button"
                              variant="ghost"
                              size="icon"
                              className="group relative flex items-center justify-center h-8 w-8 rounded-full border transition-all cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed bg-white/5 border-white/20 hover:bg-white/10 hover:border-white/30 flex-shrink-0"
                              title="Attach file"
                            >
                              <Paperclip className="h-4 w-4 text-white/70 group-hover:text-white/80 transition-all" />
                            </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent
                            align="start"
                            side="top"
                            sideOffset={8}
                            className="bg-white/10 border border-white/20 backdrop-blur-xl"
                          >
                            <DropdownMenuItem
                              onSelect={(e) => {
                                e.preventDefault()
                                console.log('[DropdownMenuItem] Image selected, triggering file input')
                                const input = fileInputRefs.current.image
                                console.log('[DropdownMenuItem] File input ref:', {
                                  exists: !!input,
                                  type: input?.type,
                                  accept: input?.accept
                                })
                                if (input) {
                                  input.click()
                                  console.log('[DropdownMenuItem] File input click() called')
                                } else {
                                  console.error('[DropdownMenuItem] File input ref is null!')
                                }
                              }}
                              className="cursor-pointer"
                            >
                              <ImageIcon className="h-4 w-4 text-white/70 mr-2" />
                              <span className="text-white/90">Image</span>
                            </DropdownMenuItem>
                            <input
                              ref={(el) => {
                                fileInputRefs.current.image = el
                                console.log('[File Input Ref] Image input ref set:', {
                                  exists: !!el,
                                  type: el?.type,
                                  accept: el?.accept
                                })
                              }}
                              type="file"
                              accept="image/*"
                              className="hidden"
                              onChange={(event) => {
                                console.log('[File Input] Image onChange triggered:', {
                                  hasFiles: !!event.target.files,
                                  filesCount: event.target.files?.length || 0,
                                  files: event.target.files ? Array.from(event.target.files).map(f => ({
                                    name: f.name,
                                    type: f.type,
                                    size: f.size
                                  })) : null
                                })
                                
                                const files = event.target.files ? Array.from(event.target.files) : null
                                
                                if (files && files.length > 0) {
                                  console.log('[File Input] Calling handleAddFiles for images')
                                  handleAddFiles(files, "image")
                                } else {
                                  console.log('[File Input] No files to add')
                                }
                                
                                setAttachMenuOpen(false)
                                event.target.value = ""
                              }}
                              multiple
                            />
                            <DropdownMenuItem
                              onSelect={(e) => {
                                e.preventDefault()
                                console.log('[DropdownMenuItem] Video selected, triggering file input')
                                const input = fileInputRefs.current.video
                                console.log('[DropdownMenuItem] File input ref:', {
                                  exists: !!input,
                                  type: input?.type,
                                  accept: input?.accept
                                })
                                if (input) {
                                  input.click()
                                  console.log('[DropdownMenuItem] File input click() called')
                                } else {
                                  console.error('[DropdownMenuItem] File input ref is null!')
                                }
                              }}
                              className="cursor-pointer"
                            >
                              <Video className="h-4 w-4 text-white/70 mr-2" />
                              <span className="text-white/90">Video</span>
                            </DropdownMenuItem>
                            <input
                              ref={(el) => {
                                fileInputRefs.current.video = el
                                console.log('[File Input Ref] Video input ref set:', {
                                  exists: !!el,
                                  type: el?.type,
                                  accept: el?.accept
                                })
                              }}
                              type="file"
                              accept="video/*"
                              className="hidden"
                              onChange={async (event) => {
                                console.log('[File Input] Video onChange triggered:', {
                                  hasFiles: !!event.target.files,
                                  filesCount: event.target.files?.length || 0,
                                  files: event.target.files ? Array.from(event.target.files).map(f => ({
                                    name: f.name,
                                    type: f.type,
                                    size: f.size
                                  })) : null
                                })
                                
                                const files = event.target.files ? Array.from(event.target.files) : null
                                
                                if (files && files.length > 0) {
                                  console.log('[File Input] Calling handleAddFiles for videos')
                                  try {
                                    await handleAddFiles(files, "video")
                                  } catch (error) {
                                    console.error('[File Input] Error in handleAddFiles for video:', error)
                                  }
                                } else {
                                  console.log('[File Input] No files to add')
                                }
                                
                                setAttachMenuOpen(false)
                                event.target.value = ""
                              }}
                              multiple
                            />
                            <DropdownMenuItem
                              onSelect={(e) => {
                                e.preventDefault()
                                console.log('[DropdownMenuItem] Audio selected')
                                fileInputRefs.current.audio?.click()
                              }}
                              className="cursor-pointer"
                            >
                              <Mic className="h-4 w-4 text-white/70 mr-2" />
                              <span className="text-white/90">Audio File</span>
                            </DropdownMenuItem>
                            <input
                              ref={(el) => { fileInputRefs.current.audio = el }}
                              type="file"
                              accept="audio/*"
                              className="hidden"
                              onChange={(event) => {
                                console.log('[File Input] Audio onChange triggered:', {
                                  hasFiles: !!event.target.files,
                                  filesCount: event.target.files?.length || 0
                                })
                                
                                const files = event.target.files ? Array.from(event.target.files) : null
                                
                                if (files && files.length > 0) {
                                  console.log('[File Input] Calling handleAddFiles for audio')
                                  handleAddFiles(files, "audio")
                                }
                                
                                setAttachMenuOpen(false)
                                event.target.value = ""
                              }}
                              multiple
                            />
                            <DropdownMenuItem
                              onSelect={(e) => {
                                e.preventDefault()
                                console.log('[DropdownMenuItem] Document selected')
                                fileInputRefs.current.document?.click()
                              }}
                              className="cursor-pointer"
                            >
                              <FileText className="h-4 w-4 text-white/70 mr-2" />
                              <span className="text-white/90">Document</span>
                            </DropdownMenuItem>
                            <input
                              ref={(el) => { fileInputRefs.current.document = el }}
                              type="file"
                              accept=".pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.rtf,application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-powerpoint,application/vnd.openxmlformats-officedocument.presentationml.presentation,text/plain,application/rtf"
                              className="hidden"
                              onChange={(event) => {
                                console.log('[File Input] Document onChange triggered:', {
                                  hasFiles: !!event.target.files,
                                  filesCount: event.target.files?.length || 0
                                })
                                
                                const files = event.target.files ? Array.from(event.target.files) : null
                                
                                if (files && files.length > 0) {
                                  console.log('[File Input] Calling handleAddFiles for documents')
                                  handleAddFiles(files, "file")
                                }
                                
                                setAttachMenuOpen(false)
                                event.target.value = ""
                              }}
                              multiple
                            />
                            <DropdownMenuItem
                              onSelect={(e) => {
                                e.preventDefault()
                                setIsVoiceRecorderOpen(true)
                                setAttachMenuOpen(false)
                              }}
                              className="cursor-pointer"
                              disabled={isVoiceRecorderOpen}
                            >
                              <Mic className="h-4 w-4 text-white/70 mr-2" />
                              <span className="text-white/90">Voice Note</span>
                            </DropdownMenuItem>
                          </DropdownMenuContent>
                        </DropdownMenu>
                        <EmojiPicker
                          onEmojiSelect={handleEmojiSelect}
                          disabled={isSending || isVoiceRecorderOpen || composerDisabled}
                        />
                      </div>
                      <textarea
                        ref={textareaRef}
                        value={composerValue}
                        onChange={(event) => handleComposerChange(event.target.value)}
                        placeholder={
                          selectedConversation.participant_status === "blocked"
                            ? "Cannot send messages"
                            : replyingToMessage
                            ? "Type your reply..."
                            : "Type a message"
                        }
                        className="flex-1 bg-transparent border-0 resize-none outline-none text-sm sm:text-[15px] text-white/80 placeholder:text-white/40 max-h-24 sm:max-h-32 min-h-[32px] leading-[1.4] overflow-y-auto pt-1.5 pb-0.5 sm:pt-2 sm:pb-1.5"
                        rows={1}
                        onKeyDown={(event) => {
                          if (event.key === "Enter" || event.keyCode === 13) {
                            // Desktop: Enter sends, Shift+Enter creates new line
                            // Mobile: Enter creates new line, Shift+Enter sends
                            
                            if (!isMobile) {
                              // DESKTOP: Enter sends, Shift+Enter creates new line
                              if (event.shiftKey) {
                                // Shift+Enter pressed: allow default (new line)
                                // Do nothing - let browser handle it
                              } else {
                                // Enter pressed (no Shift): send message
                                event.preventDefault()
                                event.stopPropagation()
                                if (!isSending && !composerDisabled) {
                                  handleSendMessage()
                                }
                              }
                            } else {
                              // MOBILE: Enter creates new line, Shift+Enter sends
                              if (event.shiftKey) {
                                // Shift+Enter pressed: send message
                                event.preventDefault()
                                event.stopPropagation()
                                handleSendMessage()
                              }
                              // Enter pressed (no Shift): allow default (new line)
                            }
                          }
                        }}
                      />
                      <Button
                        type="button"
                        disabled={isSending || composerDisabled}
                        onClick={handleSendMessage}
                        className="group relative flex items-center justify-center h-8 w-8 rounded-full border transition-all cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed bg-white/5 border-white/20 hover:bg-white/10 hover:border-white/30 flex-shrink-0"
                      >
                        {isSending ? (
                          <Loader2 className="h-4 w-4 animate-spin text-white/70 group-hover:text-white/80 transition-all" />
                        ) : (
                          <Send className="h-4 w-4 text-white/70 group-hover:text-white/80 transition-all" />
                        )}
                      </Button>
                    </div>
                  </div>
                </div>
              </>
            ) : (
              <div className="flex-1 flex flex-col items-center justify-center text-center px-8 py-12 gap-4">
                <div className="h-14 w-14 rounded-full bg-white/10 border border-white/15 flex items-center justify-center text-white/70">
                  <MessageCircle className="h-6 w-6" />
                </div>
                <div className="space-y-2">
                  <h3 className="text-white/90 text-lg font-semibold">Your inbox is ready</h3>
                  <p className="text-white/50 text-sm max-w-sm mx-auto">
                    Start a conversation by messaging someone. Messages appear here instantly with realtime updates.
                  </p>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}

